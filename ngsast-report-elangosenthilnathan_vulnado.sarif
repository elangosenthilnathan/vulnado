{
  "runs": [
    {
      "tool": {
        "driver": {
          "name": "Qwiet preZero",
          "rules": [
            {
              "id": "oss_vuln",
              "help": {
                "text": "Path Equivalence: 'file.Name' (Internal Dot) leading to\u00a0Remote Code Execution and/or Information disclosure\u00a0and/or malicious content added to uploaded files via write enabled\u00a0Default Servlet\u00a0in Apache Tomcat.\n\nThis issue affects Apache Tomcat: from 11.0.0-M1 through 11.0.2, from 10.1.0-M1 through 10.1.34, from 9.0.0.M1 through 9.0.98.\n\nIf all of the following were true, a malicious user was able to view security sensitive files and/or inject content into those files:\n-\u00a0writes enabled for the default servlet (disabled by default)\n- support for partial PUT (enabled by default)\n- a target URL for security sensitive uploads that was a sub-directory of\u00a0a target URL for public uploads\n-\u00a0attacker knowledge of the names of security sensitive files being\u00a0uploaded\n-\u00a0the security sensitive files also being uploaded via partial PUT\n\nIf all of the following were true, a malicious user was able to perform remote code execution:\n- writes enabled for the default servlet (disabled by default)\n-\u00a0support for partial PUT (enabled by default)\n-\u00a0application was using Tomcat's file based session persistence with the\u00a0default storage location\n-\u00a0application included a library that may be leveraged in a\u00a0deserialization attack\n\nUsers are recommended to upgrade to version 11.0.3, 10.1.35 or 9.0.98, which fixes the issue.",
                "markdown": "Path Equivalence: 'file.Name' (Internal Dot) leading to\u00a0Remote Code Execution and/or Information disclosure\u00a0and/or malicious content added to uploaded files via write enabled\u00a0Default Servlet\u00a0in Apache Tomcat.\n\nThis issue affects Apache Tomcat: from 11.0.0-M1 through 11.0.2, from 10.1.0-M1 through 10.1.34, from 9.0.0.M1 through 9.0.98.\n\nIf all of the following were true, a malicious user was able to view security sensitive files and/or inject content into those files:\n-\u00a0writes enabled for the default servlet (disabled by default)\n- support for partial PUT (enabled by default)\n- a target URL for security sensitive uploads that was a sub-directory of\u00a0a target URL for public uploads\n-\u00a0attacker knowledge of the names of security sensitive files being\u00a0uploaded\n-\u00a0the security sensitive files also being uploaded via partial PUT\n\nIf all of the following were true, a malicious user was able to perform remote code execution:\n- writes enabled for the default servlet (disabled by default)\n-\u00a0support for partial PUT (enabled by default)\n-\u00a0application was using Tomcat's file based session persistence with the\u00a0default storage location\n-\u00a0application included a library that may be leveraged in a\u00a0deserialization attack\n\nUsers are recommended to upgrade to version 11.0.3, 10.1.35 or 9.0.98, which fixes the issue."
              },
              "name": "Pkg",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Path Equivalence: 'file.Name' (Internal Dot) leading to\u00a0Remote Code Execution and/or Information disclosure\u00a0and/or malicious content added to uploaded files via write enabled\u00a0Default Servlet\u00a0in Apache Tomcat."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Path Equivalence: 'file.Name' (Internal Dot) leading to\u00a0Remote Code Execution and/or Information disclosure\u00a0and/or malicious content added to uploaded files via write enabled\u00a0Default Servlet\u00a0in Apache Tomcat.\n\nThis issue affects Apache Tomcat: from 11.0.0-M1 through 11.0.2, from 10.1.0-M1 through 10.1.34, from 9.0.0.M1 through 9.0.98.\n\nIf all of the following were true, a malicious user was able to view security sensitive files and/or inject content into those files:\n-\u00a0writes enabled for the default servlet (disabled by default)\n- support for partial PUT (enabled by default)\n- a target URL for security sensitive uploads that was a sub-directory of\u00a0a target URL for public uploads\n-\u00a0attacker knowledge of the names of security sensitive files being\u00a0uploaded\n-\u00a0the security sensitive files also being uploaded via partial PUT\n\nIf all of the following were true, a malicious user was able to perform remote code execution:\n- writes enabled for the default servlet (disabled by default)\n-\u00a0support for partial PUT (enabled by default)\n-\u00a0application was using Tomcat's file based session persistence with the\u00a0default storage location\n-\u00a0application included a library that may be leveraged in a\u00a0deserialization attack\n\nUsers are recommended to upgrade to version 11.0.3, 10.1.35 or 9.0.98, which fixes the issue."
              }
            },
            {
              "id": "overly-permissive-cors",
              "help": {
                "text": "The application allows all domains to send cross-origin requests \nusing the @CrossOrigin(origins = \"*\") annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that GET requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a GET request to the destination URL. This means that links into your website from\nexternal domains will almost always be GET requests. To make sure your users don't experience unexpected actions when\nclicking on links, GET requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by POST, PUT  and DELETE requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with GET requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\njava\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\njava\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\nhtml\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\ntypescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the HttpClientXsrfModule module:\n\ntypescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\ncsharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\nhtml\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\ncsharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute ValidateAntiForgeryTokenAttribute.\nHere's how you would protect an account deletion action from CSRF attacks: \n\ncsharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\njavascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the csurf library in Node.js to write out anti-forgery tokens:\n\njavascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    <form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\npython\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the CSRFProtect extension:\n\npython\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\nhtml\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\nhtml\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n\n\nIn the Django web-framework, CSRF protection is provided by the django.middleware.csrf.CsrfViewMiddleware class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\njsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\nscala\nGET   /profile/delete          controllers.Profile.delete\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The play.filters.csrf.CSRFFilter will add an\nanti-forgery token to responses securely:\n\nscala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n\n\nYou can access token to add it to your forms and AJAX requests by calling CSRF.getToken.get, or using the built-in\nhelper methods for form-building:\n\nscala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n\n\nWhich will render a form like:\n\nhtml\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\ngo\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the gorilla/csrf package:\n\ngo\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\ngo\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\njavascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a GET request:\n\nphp\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with ?deleteAccount=true, leading to the unintended deletion of their account. To avoid this, use a POST request:\n\nphp\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \nphp\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n\n\n2. **Including the token in forms**:\n\nhtml\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n\n\n3. **Validating the token**:\n\nphp\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe Same-Site cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the Same-Site attribute is set appropriately.\n\nA Same-Site value of Strict will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of Lax permits GET request from a third-party domain to *your* domain to have cookies attached - but *only* \nGET requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your GET requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the HttpOnly \n  and Secure attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring GET requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html).",
                "markdown": "The application allows all domains to send cross-origin requests \nusing the `@CrossOrigin(origins = \"*\")` annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)."
              },
              "name": "Cross-siteRequestForgery",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application allows all domains to send cross-origin requests ."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Cross-Site Request Forgery"
              }
            },
            {
              "id": "CKV2_AWS_41",
              "help": {
                "text": "The application allows all domains to send cross-origin requests \nusing the @CrossOrigin(origins = \"*\") annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that GET requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a GET request to the destination URL. This means that links into your website from\nexternal domains will almost always be GET requests. To make sure your users don't experience unexpected actions when\nclicking on links, GET requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by POST, PUT  and DELETE requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with GET requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\njava\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\njava\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\nhtml\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\ntypescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the HttpClientXsrfModule module:\n\ntypescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\ncsharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\nhtml\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\ncsharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute ValidateAntiForgeryTokenAttribute.\nHere's how you would protect an account deletion action from CSRF attacks: \n\ncsharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\njavascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the csurf library in Node.js to write out anti-forgery tokens:\n\njavascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    <form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\npython\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the CSRFProtect extension:\n\npython\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\nhtml\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\nhtml\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n\n\nIn the Django web-framework, CSRF protection is provided by the django.middleware.csrf.CsrfViewMiddleware class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\njsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\nscala\nGET   /profile/delete          controllers.Profile.delete\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The play.filters.csrf.CSRFFilter will add an\nanti-forgery token to responses securely:\n\nscala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n\n\nYou can access token to add it to your forms and AJAX requests by calling CSRF.getToken.get, or using the built-in\nhelper methods for form-building:\n\nscala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n\n\nWhich will render a form like:\n\nhtml\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\ngo\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the gorilla/csrf package:\n\ngo\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\ngo\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\njavascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a GET request:\n\nphp\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with ?deleteAccount=true, leading to the unintended deletion of their account. To avoid this, use a POST request:\n\nphp\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \nphp\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n\n\n2. **Including the token in forms**:\n\nhtml\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n\n\n3. **Validating the token**:\n\nphp\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe Same-Site cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the Same-Site attribute is set appropriately.\n\nA Same-Site value of Strict will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of Lax permits GET request from a third-party domain to *your* domain to have cookies attached - but *only* \nGET requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your GET requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the HttpOnly \n  and Secure attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring GET requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html).",
                "markdown": "The application allows all domains to send cross-origin requests \nusing the `@CrossOrigin(origins = \"*\")` annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)."
              },
              "name": "EnsureAnIamRoleIsAttachedToEc2Instance",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application allows all domains to send cross-origin requests ."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure an IAM role is attached to EC2 instance"
              }
            },
            {
              "id": "CKV2_AWS_12",
              "help": {
                "text": "The application allows all domains to send cross-origin requests \nusing the @CrossOrigin(origins = \"*\") annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that GET requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a GET request to the destination URL. This means that links into your website from\nexternal domains will almost always be GET requests. To make sure your users don't experience unexpected actions when\nclicking on links, GET requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by POST, PUT  and DELETE requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with GET requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\njava\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\njava\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\nhtml\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\ntypescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the HttpClientXsrfModule module:\n\ntypescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\ncsharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\nhtml\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\ncsharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute ValidateAntiForgeryTokenAttribute.\nHere's how you would protect an account deletion action from CSRF attacks: \n\ncsharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\njavascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the csurf library in Node.js to write out anti-forgery tokens:\n\njavascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    <form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\npython\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the CSRFProtect extension:\n\npython\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\nhtml\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\nhtml\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n\n\nIn the Django web-framework, CSRF protection is provided by the django.middleware.csrf.CsrfViewMiddleware class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf an attacker tricks a user into clicking on a link to www.yoursite.com/logout, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via PUT or \nDELETE requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as <meta> tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\njsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\njsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\nscala\nGET   /profile/delete          controllers.Profile.delete\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The play.filters.csrf.CSRFFilter will add an\nanti-forgery token to responses securely:\n\nscala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n\n\nYou can access token to add it to your forms and AJAX requests by calling CSRF.getToken.get, or using the built-in\nhelper methods for form-building:\n\nscala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n\n\nWhich will render a form like:\n\nhtml\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\ngo\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n\n\nIf an attacker tricks a user into clicking on a link to /profile/delete their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via PUT or DELETE requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-GET requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. POST, PUT  and DELETE requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the gorilla/csrf package:\n\ngo\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\ngo\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\njavascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a GET request:\n\nphp\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with ?deleteAccount=true, leading to the unintended deletion of their account. To avoid this, use a POST request:\n\nphp\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \nphp\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n\n\n2. **Including the token in forms**:\n\nhtml\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n\n\n3. **Validating the token**:\n\nphp\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe Same-Site cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the Same-Site attribute is set appropriately.\n\nA Same-Site value of Strict will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of Lax permits GET request from a third-party domain to *your* domain to have cookies attached - but *only* \nGET requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your GET requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the HttpOnly \n  and Secure attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring GET requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html).",
                "markdown": "The application allows all domains to send cross-origin requests \nusing the `@CrossOrigin(origins = \"*\")` annotation. This exposes the application to potential \nsecurity risks, including unauthorized data access and cross-site scripting (XSS) attacks, by not \nrestricting the origins that can interact with the server.\n\n# Cross-Site Request Forgery\n\n**Cross-site request forgery** (CSRF) vulnerabilities can be used to trick a user into performing an unwanted action on\nyour website.\n\nWebsites consist of a combination of client-side and server-side code. The client-side code is the HTML and JavaScript that\nis rendered by and executed in the browser. This client-side code allows users to navigate to other URLs, submit HTML\nforms, and trigger AJAX requests via JavaScript. Your server-side code will intercept the data sent in the resulting\nHTTP requests, and act upon it appropriately.\n\nThese server-side actions can also be triggered by *forged* HTTP requests unless you explicitly put in protective\nmeasures. A forged request is when a malicious actor tricks a victim into clicking on a link, submitting a form, or \nrunning some code that triggers an unexpected action. This malicious code is typically hosted on a website controlled by \nthe attacker, on another domain - hence the *cross-site* part of the name.\n\nProtecting against CSRF requires two things: ensuring that `GET` requests are **side effect free**, and ensuring that\nother requests do not originate from a third-party site by using **anti-forgery tokens**.\n\n\n## Making GET Requests Side Effect Free\n\nHyperlinks on the internet trigger a `GET` request to the destination URL. This means that links into your website from\nexternal domains will almost always be `GET` requests. To make sure your users don't experience unexpected actions when\nclicking on links, `GET` requests should only retrieve resources from the server - never *change state* on the server. Anything\nthat changes state - a *side effect* - should be handled by `POST`, `PUT`  and `DELETE` requests, depending on whether\nthe request is adding, updating or deleting state.\n\nHere are some examples of side effects that should **not** be performed with `GET` requests:\n\n* Logging in\n* Logging out\n* Password resets\n* Sign-ups \n* Posting or editing content\n* Account deletion\n\n::::tabs\n\n:::tab[Java]\n\nFor example, consider the following implementation of an \"Account Deletion\" function:\n\n```java\n@WebServlet(\"/profile/delete\")\npublic class AccountDeletionServlet extends HttpServlet\n{\n    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException\n    {\n        HttpSession session  = request.getSession();\n        String      username = (String) session.getAttribute(\"username\");\n\n        getDatabase().deleteUser(username);\n\n        session.invalidate();\n        response.sendRedirect(\"/\");\n    }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn a Java web application, this functionality is often achieved by implementing a filter:\n\n```java\n/**\n * A simple Filter that generates CSRF tokens, puts them in a cookie, and passes them downstream\n * as a request attribute, so they can be added to HTML forms. When a form is submitted the\n * filter validates that the value in the form and the value in the cookie match - thus ensuring\n * the request originated from our domain.\n *\n * To handle AJAX requests, CSRF tokens should be passed in a \"CSRF\" header.\n */\npublic class CSRFProtectionFilter extends HttpFilter\n{\n    private final static List METHODS_TO_PROTECT = Arrays.asList(\"PUT\", \"POST\", \"DELETE\");\n\n    @Override\n    protected void doFilter(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException\n    {\n        // Extract the CSRF token from the cookie if we can find it.\n        String csrfTokenFromCookie = null;\n\n        if (request.getCookies() != null) {\n            for (Cookie cookie : request.getCookies()) {\n                if (cookie.getName().equals(\"CSRF\")) {\n                    csrfTokenFromCookie = cookie.getValue();\n                }\n            }\n        }\n\n        // For sensitive HTTP methods check a matching token is sent in an HTML form\n        // parameter or in an HTTP header.\n        if (METHODS_TO_PROTECT.contains(request.getMethod())) {\n            if (csrfTokenFromCookie == null)\n                throw new ServletException(\"Missing CSRF token in cookie\");\n\n            String csrfTokenFromBody   = request.getParameter(\"CSRF\");\n            String csrfTokenFromHeader = request.getHeader(\"CSRF\");\n\n            if (csrfTokenFromBody == null && csrfTokenFromHeader == null)\n                throw new ServletException(\"Missing CSRF token in body\");\n\n            if (csrfTokenFromBody != null && !csrfTokenFromBody.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n\n            if (csrfTokenFromHeader != null && !csrfTokenFromHeader.equals(csrfTokenFromCookie))\n                throw new ServletException(\"Mismatched CSRF tokens\");\n        }\n\n        // If this a GET request, we may not have set the CSRF token in the cookie.\n        // Generate it now, and attach it to the request.\n        if (csrfTokenFromCookie == null) {\n            String newCSRFToken = generateCSRFToken();\n\n            // Ensure the cookie is not accessible from JavaScript, and\n            // is only sent over HTTPS. Strip cookies from all but GET\n            // requests from other sites.\n            response.addHeader(\"Set-Cookie\", \"CSRF=\" + newCSRFToken + \"; HttpOnly; Secure; SameSite=Lax\");\n            request.setAttribute(\"CSRF\", newCSRFToken);\n        }\n        else {\n            request.setAttribute(\"CSRF\", csrfTokenFromCookie);\n        }\n\n        chain.doFilter(request, response);\n    }\n\n    /**\n     * Generate a CSRF token from a securely random number.\n     */\n    private static String generateCSRFToken() throws ServletException\n    {\n        try {\n            SecureRandom random = SecureRandom.getInstance(\"SHA1PRNG\");\n            byte[] data = new byte[16];\n            random.nextBytes(data);\n\n            return Base64.getEncoder().encodeToString(data);\n        }\n        catch (NoSuchAlgorithmException e) {\n            throw new ServletException(\"Unexpected exception generating CSRF token.\", e);\n        }\n    }\n}\n```\n\nAny forms that sit down stream of this filter can inject the CSRF token into the request they generate with a single\nline of code:\n\n```html\n<form method=\"POST\" enctype=\"multipart/form-data\" action=\"/profile/photo\">\n  \n  <!-- Inject the CSRF token to secure our uploads. -->  \n  <input type=\"hidden\" name=\"CSRF\" value=\"<%= request.getAttribute(\"CSRF\") %>\">\n  <input type=\"file\" name=\"file\" id=\"file\">\n\n  <input type=\"submit\" value=\"Upload\" name=\"upload\">\n</form>\n```\n\n:::\n\n:::tab[Angular]\n\nFor example, consider the following implementation of a \"Logout\" function in Angular:\n\n```typescript\nexport class LogoutService {\n  constructor(private http: HttpClient) {}\n\n  logout(): void {\n    // Send a GET request to the server to trigger a logout.  \n    this.http.get('/api/auth/logout').subscribe()\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it. \n\nAngular allows you to add anti-forgery tokens to HTTP requests using the `HttpClientXsrfModule` module:\n\n```typescript\n@NgModule({\n  declarations: [\n  ],\n  imports: [\n    BrowserModule,\n    HttpClientModule,\n    HttpClientXsrfModule.withOptions({\n      cookieName: 'XSRF-TOKEN',\n      headerName: 'X-CSRF-TOKEN'\n    }),\n  ],\n  providers: [],\n  bootstrap: [AppComponent]\n})\nexport class AppModule {\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and add the appropriate \ncorresponding names in your Angular configuration.\n\n:::\n\n:::tab[C#]\n\nFor example, consider the following route for an \"Account Deletion\" action in the ASP.NET core:\n\n```csharp\n[HttpGet(\"profile/delete\")]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are generated *automatically *by ASP.NET Core since version 2.0. The Razor template files that are \nused to generate HTML will have tokens injected into any forms by default. You can even make the injection of \nanti-forgery tokens explicit with the following syntax:\n\n```html\n<form action=\"/\" method=\"post\">\n    @Html.AntiForgeryToken()\n</form>\n```\n\nTo help secure AJAX requests, anti-CSRF cookies can be made available to JavaScript code defined in Razor templates in the \nfollowing manner:\n\n```csharp\n@inject Microsoft.AspNetCore.Antiforgery.IAntiforgery Xsrf\n@functions{\n    public string GetAntiXsrfRequestToken()\n    {\n        return Xsrf.GetAndStoreTokens(Context).RequestToken;\n    }\n}\n```\n\nYou can then secure your controller methods from CSRF attacks by adding the attribute `ValidateAntiForgeryTokenAttribute`.\nHere's how you would protect an account deletion action from CSRF attacks: \n\n```csharp\n[HttpDelete(\"profile\")]\n[Authorize]\n[ValidateAntiForgeryToken]\npublic async Task DeleteAccount()\n{\n    var user = await UserManager.FindByNameAsync(User.Identity.Name);\n    \n    await UserManager.DeleteAsync(user);\n    await HttpContext.SignOutAsync();\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\nFor example, consider the following implementation of an \"Account Deletion\" function in Express:\n\n```javascript\nconst express      = require('express')\nconst session      = require('express-session')\nconst cookieParser = require('cookie-parser')\nconst app          = express()\n\napp.use(cookieParser())\napp.use(session({ cookie: { maxAge: 60000 }}))\n\napp.get('/profile/delete', (request, response) => {\n  const email = request.session.email\n\n  db.run('DELETE FROM users WHERE email = ?', [ email ], () => {\n    response.redirect('/')\n  })\n})\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nHere is how to use the `csurf` library in Node.js to write out anti-forgery tokens:\n\n```javascript\nconst cookieParser = require('cookie-parser')\nconst bodyParser   = require('body-parser')\n\nconst app = express()\n\nconst csrf           = require('csurf')\nconst csrfProtection = csrf({ cookie: true })\nconst parseForm      = bodyParser.urlencoded({ extended: false })\n\napp.use(cookieParser())\n\n/**\n * We set the '_csrf' value in the Cookie and the login form, so we\n * can cross check them during the login process.\n */\napp.get('/login', csrfProtection, (request, response) => {\n  response.send(\n    `<form action=\"/login\" method=\"POST\">\n       <input type=\"hidden\"   name=\"_csrf\"    value=\"${request.csrfToken()}\">\n       <input type=\"text\"     name=\"Username\" value=\"\">\n       <input type=\"password\" name=\"password\" value=\"\">\n  \n       <button type=\"submit\">Login</button>\n    </form>`\n  )\n})\n\n/**\n * Here the 'csrfProtection' function cross-checks the CSRF token in the Cookie\n * and that in the form, and rejects the request if they don't match.\n */\napp.post('/login', parseForm, csrfProtection, (request, response) => {\n  response.send('CSRF cookie validated!')\n})\n```\n\n:::\n\n:::tab[Python]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Flask web-server:\n\n```python\n@app.route('/profile/delete', methods=['GET'])\ndef delete_post(post_id):\n  user = session['user']\n    \n  with database() as db:\n    db.execute('delete from users where id = ?', user['id'])\n    del session['user']\n      \n  return redirect('/')\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added in Flask web-server by registering the `CSRFProtect` extension:\n\n```python\nfrom flask import Flask\nfrom flask_wtf.csrf import CSRFProtect\n\napp  = Flask(__name__)\ncsrf = CSRFProtect(app)\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```html\n<form method=\"post\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"{{ csrf_token() }}\"/>\n</form>\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```html\n<script type=\"text/javascript\">\n    var csrf_token = \"{{ csrf_token() }}\";\n\n    $.ajaxSetup({\n        beforeSend: function(xhr, settings) {\n            if (!/^(GET|HEAD|OPTIONS|TRACE)$/i.test(settings.type) && !this.crossDomain) {\n                xhr.setRequestHeader(\"X-CSRFToken\", csrf_token);\n            }\n        }\n    });\n</script>\n```\n\nIn the Django web-framework, CSRF protection is provided by the `django.middleware.csrf.CsrfViewMiddleware` class.\n\n:::\n\n:::tab[React]\n\nFor example, consider the following implementation of a \"Logout\" function in React:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server.\n    const response = await fetch(\"/logout\", {\n      method: 'GET'\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `www.yoursite.com/logout`, that user will be logged out before \nthey are aware of what is happening. For this reason, it's recommended to implement logout functionality via `PUT` or \n`DELETE` requests. The situation becomes even more dire in the event of e.g. account deletion functionality: you will \nhave real problems if attackers can trick users into accidentally deleting their accounts.\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects. These tokens are called **anti-forgery tokens**. \n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nsent to the browser. The server will compare the token attached to any inbound requests with the original value. \nIf the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens should be generated on the web-server and provided to client-side code in some fashion - typically\nthey are written out as `<meta>` tags in the HTML header, or loaded asynchronously via an AJAX call. Any subsequent AJAX \ncalls should pass the token back in an HTTP header, so the server can validate it:\n\n```jsx\nclass Logout extends React.Component {\n  constructor(props) {\n    super(props)\n\n    this.updateLoginStatus = props.updateLoginStatus\n  }\n\n  async logout() {\n    \n    // Invalidate the session on the server, passing back the anti-forgery token\n    // in an HTTP header. The browser will attach a matching value in a cookie.\n    const response = await fetch(\"/logout\", {\n      method: 'DELETE',\n      headers: {\n        'CSRF-Token' : this.props.csrf\n      }\n    })\n\n    if (response.ok) {\n      \n      // Set the login status to \"Logged out\" and the username to null in the component state.\n      this.updateLoginStatus(false, null)\n    }\n  }\n\n  render() {\n    return (\n      <a onClick={() => { this.logout() }}>\n        Logout\n      </a>\n    )\n  }\n}\n```\n\nIf you generate HTTP requests using HTML forms, you should add the anti-forgery token in a hidden field of the form:\n\n```jsx\nfunction Comment(props) {\n  return (\n    <div className=\"post\">\n      <form action=\"/comment\" method=\"POST\">\n        <textarea name=\"comment\" placeholder=\"What's on your mind?\"/>\n        <input type=\"hidden\" name=\"_csrf\" value={props.csrf} />\n        <button type=\"submit\">Add Comment</button>\n      </form>\n    </div>\n  )\n}\n```\n\nThe name of the header and the name of the hidden form field will depend on what library you are using to generate your\nanti-forgery tokens on the server-side. Consult the library's documentation for details, and update your React code\naccordingly.\n\n:::\n\n:::tab[Scala]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Play framework:\n\n```scala\nGET   /profile/delete          controllers.Profile.delete\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nIn the Play framework, CSRF protection is enabled automatically. The `play.filters.csrf.CSRFFilter` will add an\nanti-forgery token to responses securely:\n\n```scala\n  def addTokenToResponse(request: RequestHeader, result: Result): Result = {\n    request.attrs.get(CSRF.Token.InfoAttr) match {\n      case None =>\n        filterLogger.warn(\"[CSRF] No token found on request!\")\n        result\n      case Some(tokenInfo) if {\n            tokenIsHttpOnly &&                             // the token is not going to be accessed and used from JS\n            result.body.isInstanceOf[HttpEntity.Strict] && // the body was fully rendered\n            !tokenInfo.wasRendered                         // the token was not rendered in the body of the response\n          } =>\n        filterLogger.trace(\"[CSRF] Not emitting CSRF token because token was never rendered\")\n        result\n      case _ if isCacheableBySharedCache(result) =>\n        filterLogger.trace(\"[CSRF] Not adding token to response that might get cached by a shared cache (e.g. proxies)\")\n        result\n      case Some(tokenInfo) =>\n        val Token(tokenName, tokenValue) = tokenInfo.toToken\n        filterLogger.trace(\"[CSRF] Adding token to result: \" + result)\n        csrfConfig.cookieName\n          .map { name =>\n            result.withCookies(\n              Cookie(\n                name,\n                tokenValue,\n                path = sessionConfiguration.path,\n                domain = sessionConfiguration.domain,\n                secure = csrfConfig.secureCookie,\n                httpOnly = csrfConfig.httpOnlyCookie,\n                sameSite = csrfConfig.sameSiteCookie\n              )\n            )\n          }\n          .getOrElse {\n            val newSession = result.session(request) + (tokenName -> tokenValue)\n            result.withSession(newSession)\n          }\n    }\n  }\n```\n\nYou can access token to add it to your forms and AJAX requests by calling `CSRF.getToken.get`, or using the built-in\nhelper methods for form-building:\n\n```scala\n@form(routes.ItemsController.save()) {\n    @CSRF.formField\n    ...\n}\n```\n\nWhich will render a form like:\n\n```html\n<form method=\"POST\" action=\"/items\">\n   <input type=\"hidden\" name=\"csrfToken\" value=\"1234567890abcdef\"/>\n   ...\n</form>\n```\n\n:::\n\n:::tab[Go]\n\nFor example, consider the following route for an \"Account Deletion\" action in the Gorilla web toolkit:\n\n```go\nfunc DeleteProfileHandler(response http.ResponseWriter, request *http.Request) {\n  session, err := session.Get(request, \"session\")\n\n  if err != nil {\n    http.Error(response, \"Error loading session\", http.StatusInternalServerError)\n    return\n  }\n\n  userId := session.Values[\"userId\"]\n\n  deleteUser(userId)\n\n  session.Options.MaxAge = -1\n\n  err = session.Save(request, response)\n\n  if err != nil {\n    http.Error(response, \"Error saving session\", http.StatusInternalServerError)\n    return\n  }\n\n  http.Redirect(response, request, \"/\", http.StatusOK)\n}\n```\n\nIf an attacker tricks a user into clicking on a link to `/profile/delete` their account will be deleted before they are \naware of what is happening. This is why it's important to implement account deletion via `PUT` or `DELETE` requests - \nand to confirm the action with the user before deleting their account!\n\n## Anti-Forgery Tokens\n\nOnce you have restricted your side effects are to non-`GET` requests, you need to protect against malicious HTTP \nrequests that use the other HTTP verbs. `POST`, `PUT`  and `DELETE` requests can still be sent to your site from HTML \nforms and JavaScript code hosted on other domains. It is harder for an attacker to forge these type of requests - they \nwill need the user to do more than click on a single malicious link - but it is still possible.\n\nTo ensure that you only handle valid requests for these HTTP verbs, you need to include a **secret** and \n**unique** token with each HTTP response, and have the server verify that token when it is passed back in subsequent \nrequests that has side effects.\n\nThese tokens are called **anti-forgery tokens**. Each time your server renders a page that performs sensitive actions, \nit should write out an anti-forgery token in a hidden HTML form field. This token must be included with form \nsubmissions, or AJAX calls. The server should validate the token when it is returned in subsequent requests, and reject \nany calls with missing or invalid tokens.\n\nAnti-forgery tokens are typically (strongly) random numbers that are stored in a cookie or on the server as they are \nwritten out to the hidden field. The server will compare the token attached to the inbound request with the stored \nvalue. If the values are identical, the server will accept the valid HTTP request.\n\nAnti-forgery tokens are easily added using the `gorilla/csrf` package:\n\n```go\nfunc main() {\n  router := mux.NewRouter()\n  router.HandleFunc(\"/signup\", ShowSignupForm)\n\n  // All POST requests without a valid token will return HTTP 403 Forbidden.\n  // We should also ensure that our mutating (non-idempotent) handler only\n  // matches on POST requests. We can check that here, at the router level, or\n  // within the handler itself via r.Method.\n  router.HandleFunc(\"/signup/post\", SubmitSignupForm).Methods(\"POST\")\n\n  // Add the middleware to your router by wrapping it.\n  http.ListenAndServe(\":8000\",\n  csrf.Protect([]byte(\"32-byte-long-auth-key\"))(router))\n  \n  // PS: Don't forget to pass csrf.Secure(false) if you're developing locally\n  // over plain HTTP (just don't leave it on in production).\n}\n```\n\nAny HTML forms generated by templates should add the relevant form field as follows:\n\n```go\nfunc ShowSignupForm(w http.ResponseWriter, r *http.Request) {\n  // signup_form.tmpl just needs a {{ .csrfField }} template tag for\n  // csrf.TemplateField to inject the CSRF token into. Easy!\n  t.ExecuteTemplate(w, \"signup_form.tmpl\", map[string]interface{}{\n      csrf.TemplateTag: csrf.TemplateField(r),\n  })\n}\n```\n\nAJAX requests can similarly be amended to include anti-forgery tokens in the following manner:\n\n```javascript\n// Find the CSRF token.\nlet csrfToken = document.getElementsByName(\"gorilla.csrf.Token\")[0].value\n\n// Add the CSRF token to e.g. the Axios AJAX client.\nconst instance = axios.create({\n  baseURL: \"https://example.com/api/\",\n  timeout: 1000,\n  headers: { \"X-CSRF-Token\": csrfToken }\n})\n```\n\n:::\n\n:::tab[PHP]\n\nFor example, here's a potentially dangerous PHP script that deletes a user's account based on a `GET` request:\n\n```php\n<?php\nif (isset($_GET['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n```\n\nBy having such code, a malicious actor could trick a user's browser into making a request to a URL with `?deleteAccount=true`, leading to the unintended deletion of their account. To avoid this, use a `POST` request:\n\n```php\n<?php\nif (isset($_POST['deleteAccount'])) {\n    deleteUserAccount($_SESSION['userId']);\n    header('Location: /');\n}\n?>\n\n<form method=\"POST\" action=\"\">\n    <button name=\"deleteAccount\" value=\"true\">Delete Account</button>\n</form>\n```\n\n## Anti-Forgery Tokens in PHP\n\nTo mitigate CSRF attacks in PHP applications, use anti-forgery tokens. One popular way is to generate and validate CSRF tokens using PHP sessions.\n\n1. **Generating the CSRF token**:\n   \n```php\nsession_start();\n\nif (empty($_SESSION['csrf_token'])) {\n    $_SESSION['csrf_token'] = bin2hex(random_bytes(32));\n}\n\n$csrf_token = $_SESSION['csrf_token'];\n```\n\n2. **Including the token in forms**:\n\n```html\n<form method=\"POST\" action=\"\">\n    <input type=\"hidden\" name=\"csrf_token\" value=\"<?php echo $csrf_token; ?>\">\n    <button type=\"submit\" name=\"submitAction\">Perform Action</button>\n</form>\n```\n\n3. **Validating the token**:\n\n```php\nif ($_SERVER['REQUEST_METHOD'] !== 'GET' && $_SERVER['REQUEST_METHOD'] !== 'HEAD') {\n    if (!isset($_SESSION['csrf_token']) || !isset($_POST['csrf_token'])) {\n        // Token not provided or not yet generated for session - potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    $expectedToken = $_SESSION['csrf_token'];\n    $userToken = $_POST['csrf_token'];\n\n    if (!hash_equals($expectedToken, $userToken)) {\n        // Token validation failed, potential CSRF attack.\n        die('Invalid request.');\n    }\n\n    // Continue with the intended action\n    performSensitiveAction();\n}\n```\n\nUsing anti-forgery tokens ensures that the action is only executed if the request originates from your domain and the token matches the one in the user's session.\n\n:::\n\n::::\n\n### Ensure Cookies Are Sent With The SameSite Cookie Attribute\n\nThe `Same-Site` cookie attribute instructs the browser whether to send cookies with requests initiated by third-party \ndomains. Since anti-forgery tokens are typically validated by comparing the token value sent in the HTML form with a \nvalue in a cookie, they are only effective when the `Same-Site` attribute is set appropriately.\n\nA `Same-Site` value of `Strict` will mean than *any* request initiated by a third-party domain to *your* domain will not \nhave any cookies attacked. This is the most secure setting, since it prevents malicious sites attempting to perform\nharmful actions under a user's session.\n\nA value of `Lax` permits `GET` request from a third-party domain to *your* domain to have cookies attached - but *only* \n`GET` requests. With this setting a user will not have to sign in again to your site if they follow a link from another \nsite (say, Google search results). This makes for a friendlier user-experience - but make sure your `GET` requests are \nside effect free!\n\n## Further Considerations\n\n* Make sure your cookies cannot be accessed in JavaScript, and are only sent over HTTPS. This is done by adding the `HttpOnly` \n  and `Secure` attributes to each cookie.\n  \n* Many sites require a secondary authentication step, or require re-confirmation of login details when the user performs \n  a sensitive action. (Think of a typical  password reset page - usually the user will have to specify their old \n  password before setting a new password.) Not only does this protect users who may accidentally leave themselves \n  logged in on publicly accessible computers, but it also greatly reduces the possibility of CSRF attacks.\n  \n* Ensuring `GET` requests are side effect free is part of a series of design principles called *Representation State \n  Transfer (REST)* that assign certain types of action (view, create, delete, update) to different HTTP verbs. \n  REST insists that GET requests are used only to *view* resources. \n  \n## CWEs\n\n* [CWE-352](https://cwe.mitre.org/data/definitions/352.html)."
              },
              "name": "EnsureTheDefaultSecurityGroupOfEveryVpcRestrictsAllTraffic",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application allows all domains to send cross-origin requests ."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure the default security group of every VPC restricts all traffic"
              }
            },
            {
              "id": "CKV2_AWS_11",
              "help": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**.",
                "markdown": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**."
              },
              "name": "EnsureVpcFlowLoggingIsEnabledInAllVpcs",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure VPC flow logging is enabled in all VPCs"
              }
            },
            {
              "id": "exit-from-attacker-controlled",
              "help": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**.",
                "markdown": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**."
              },
              "name": "DenialOfService",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Denial of Service"
              }
            },
            {
              "id": "CKV_AWS_8",
              "help": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**.",
                "markdown": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**."
              },
              "name": "EnsureAllDataStoredInTheLaunchConfigurationOrInstanceElasticBlocksStoreIsSecurelyEncrypted",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"
              }
            },
            {
              "id": "CKV_AWS_126",
              "help": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**.",
                "markdown": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**."
              },
              "name": "EnsureThatDetailedMonitoringIsEnabledForEc2Instances",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure that detailed monitoring is enabled for EC2 instances"
              }
            },
            {
              "id": "CKV_AWS_79",
              "help": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**.",
                "markdown": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability.\n ## Countermeasures\n - Handle errors that can be triggered by an unauthenticated attacker in a way that does not jeopardize the availability of the service.\n ## Additional information\n **[CWE-382](https://cwe.mitre.org/data/definitions/382.html)**\n **[OWASP-a9](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_a9-Using_Components_with_Known_Vulnerabilities)**."
              },
              "name": "EnsureInstanceMetadataServiceVersion1IsNotEnabled",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The program is terminated in a code path that is reachable by an attacker. This indicates a denial of service vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure Instance Metadata Service Version 1 is not enabled"
              }
            },
            {
              "id": "CKV_AWS_135",
              "help": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "EnsureThatEc2IsEbsOptimized",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure that EC2 is EBS optimized"
              }
            },
            {
              "id": "weak-hash",
              "help": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "WeakHash",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "The application uses a weak cryptographic hash algorithm, such as MD5 or SHA1."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Weak Hash"
              }
            },
            {
              "id": "CKV_AWS_23",
              "help": {
                "text": "For many use-cases, cryptographic hashes need to be used with a salt to be effective.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "For many use-cases, cryptographic hashes need to be used with a salt to be effective.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "EnsureEverySecurityGroupAndRuleHasADescription",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "For many use-cases, cryptographic hashes need to be used with a salt to be effective."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure every security group and rule has a description"
              }
            },
            {
              "id": "unsalted-one-way-hash",
              "help": {
                "text": "For many use-cases, cryptographic hashes need to be used with a salt to be effective.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njava\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\nBCrypt is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\ncsharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\njavascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\npython\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\nscala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called BCrypt to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\ngo\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like md5() and sha1(), which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using md5 for password hashing:\n\nphp\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the password_hash() function, which by default uses the bcrypt algorithm and incorporates salting:\n\nphp\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the password_verify() function. This method safely compares a password against a hashed value:\n\nphp\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n\n\n3. **Always Include a Salt**: Modern hashing functions like password_hash() incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**.",
                "markdown": "For many use-cases, cryptographic hashes need to be used with a salt to be effective.\n\n## Weak Hashes\n\nA *hash* is a type of cryptographic algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\n::::tabs\n\n:::tab[Java]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```java\npublic String hashPassword(String password) \n{\n    return org.mindrot.BCrypt.hashpw(password, org.mindrot.BCrypt.gensalt(SALT_ROUNDS));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[C#]\n\n`BCrypt` is a strong, one-way hash called that can be used to encode passwords, and validate them as they are re-entered\nby a user. It is available in the NuGet repository and can be used as shown:\n\n```csharp\nusing BCrypt.Net;\n\n// BCrypt is a strong hash, suitable for storing passwords. Remember to add a salt value!\npublic class Hashing\n{\n    private static string GetRandomSalt()\n    {\n        return BCrypt.GenerateSalt(12);\n    }\n    \n    public static string HashPassword(string password)\n    {\n        return BCrypt.HashPassword(password, GetRandomSalt());\n    }\n    \n    public static bool ValidatePassword(string password, string correctHash)\n    {\n       \treturn BCrypt.Verify(password, correctHash);\n    }\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[JavaScript]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```javascript\nconst bcrypt  = require('bcrypt')\nconst express = require('express')\n\nconst app    = express()\n\n// Increase this value to make the hashing process take longer, and hence harder to decrypt.\nconst saltRounds = 10\n\napp.post('/signup', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is signing up - calculated their password hash and save it to the database.\n   */\n  bcrypt.hash(password, saltRounds, (error, hashedPassword) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    saveUser(username, hashedPassword)\n    response.redirect('/login')\n  })\n})\n\napp.post('/login', (request, response) => {\n  const username = request.params.username\n  const password = request.params.password\n\n  /**\n   * The user is logging back in - recalculate their password hash and\n   * compare it with the saved value.\n   */\n  const user = getUser(username)\n\n  // Calculate the password hash regardless of whether the username exists,\n  // so the attacker cannot use timing attacks to detect which users exist\n  // in the database.\n  const passwordHash = user ? user.hashedPassword : ''\n\n  bcrypt.compare(password, passwordHash, (error, matched) => {\n    if (error) {\n      response.status(400)\n      return\n    }\n\n    if (user && matched) {\n      // The password hash matches, Log the user in.\n      request.session.username = username\n      self.redirect('/')\n    }\n    else {\n      // Tell them the credentials are incorrect.\n      response.status(401)\n    }\n  })\n})\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Python]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```python\nimport bcrypt\n\n@app.route('/signup', methods=('POST',))\ndef do_signup():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is signing up - calculated their password hash and save it to the database.\n  salt   = bcrypt.gensalt()\n  hashed = bcrypt.hashpw(password, salt)\n\n  save_credentials(username, hashed)\n\n  return redirect('/login')\n\n@app.route('/login', methods=('POST',))\ndef do_login():\n  username = request.form['username']\n  password = request.form['password']\n\n  # The user is logging back in - recalculate their password hash and\n  # compare it with the saved value.\n  user   = get_user(username)\n  hashed = user.hashed_password if user else ''\n\n  # Calculate the password hash regardless of whether the username exists,\n  # so the attacker cannot use timing attacks to detect which users exist\n  # in the database.\n  if bcrypt.checkpw(password, hashed):\n    session['user'] = user\n    return redirect('/timeline')\n\n  return render_template('login.html', error='Invalid username or password')\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Scala]\n\nA *hash* is a type of encryption algorithm that produces an output of fixed length regardless of the input. Hash\nalgorithms are often used to store passwords securely in a database, or generate digital signatures which prove data has\nnot been tampered with. It is important that you use *strong hash* algorithms when securing data in this way - and\ninclude an element of randomness called a *salt* - or an attacker will be able to backwards engineer confidential\ninformation if they possess enough computing power. This often entails choosing a *one-way hash* algorithm that is\ncomputationally infeasible to reverse.\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```scala\nval SaltRounds : Int = 10\n\ndef encryptPassword(password: String) = {\n  org.mindrot.jbcrypt.BCrypt.hashpw(password, org.mindrot.jbcrypt.BCrypt.gensalt(SaltRounds));\n}\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[Go]\n\nConsider the following function that uses a strong, one-way hash called `BCrypt` to encode a password when it is set,\nand repeats the calculation when a user attempts to reauthenticate:\n\n```go\nimport (\n  \"golang.org/x/crypto/bcrypt\"\n  \"fmt\"\n)\n\nfunc HashPassword(password string) string {\n  // Each call to GenerateFromPassword(...) will use a different salt value.\n  hash, _ := bcrypt.GenerateFromPassword(password, bcrypt.DefaultCost)\n  return string(hash)\n}\n\nfunc CheckPassword(hashedPassword string, password string) bool {\n  err := bcrypt.CompareHashAndPassword(hashedPassword, password)\n  return err != nil\n}\n\n```\n\nSince the password is strongly encrypted with a one-way hash, and generated with a salt, an attacker who manages to \nsteal the contents of your database will still not be able to backwards engineer the credentials for your users.\n\n:::\n\n:::tab[PHP]\n\n## Weak Hashes in PHP\n\nIn PHP, there are older hash functions like `md5()` and `sha1()`, which, due to their vulnerabilities, shouldn't be used for sensitive operations. An attacker, equipped with rainbow tables or leveraging collisions, can reverse-engineer these hashes. Here's an example of using `md5` for password hashing:\n\n```php\nfunction insecureHashPassword($password) {\n    return md5($password);\n}\n```\n\nThis approach is flawed and insecure for the reasons stated above.\n\n## Mitigation\n\n1. **Use PHP's Built-in Password Functions**: PHP provides the `password_hash()` function, which by default uses the `bcrypt` algorithm and incorporates salting:\n\n```php\nfunction hashPasswordSecurely($password) {\n    return password_hash($password, PASSWORD_DEFAULT);\n}\n```\n\n2. **Verify Passwords Securely**: When verifying a user's password, use the `password_verify()` function. This method safely compares a password against a hashed value:\n\n```php\nfunction verifyPassword($password, $hashedPassword) {\n    return password_verify($password, $hashedPassword);\n}\n```\n\n3. **Always Include a Salt**: Modern hashing functions like `password_hash()` incorporate salting automatically. This ensures that even if two users have the same password, their hashed values will be different, thwarting rainbow table attacks.\n\n4. **Migrate Old Hashes**: If you're dealing with an older system, migrate hashes from weak algorithms to stronger ones upon user login or during a forced password reset.\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-327](https://cwe.mitre.org/data/definitions/327.html)**\n\n**[OWASP-A6](https://owasp.org/www-project-top-ten/2017/A6_2017-Security_Misconfiguration)**."
              },
              "name": "SecurityBestPractices",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "For many use-cases, cryptographic hashes need to be used with a salt to be effective."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Security Best Practices"
              }
            },
            {
              "id": "CKV_AWS_382",
              "help": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njava\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the javax.xml.validation package:\n\njava\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\njava\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\ngmaps-api-net library:\n\ncsharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ncsharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\ncsharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njavascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\njavascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\njavascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(/login)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = https://${link}\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\npython\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\npython\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\npython\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\nscala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the java.xml.validation package:\n\nscala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\nscala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\ngo\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ngo\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\ngo\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\nphp\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\nphp\n<?php\nlibxml_disable_entity_loader(true);\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\nphp\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**.",
                "markdown": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```java\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `javax.xml.validation` package:\n\n```java\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```java\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\n`gmaps-api-net` library:\n\n```csharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```csharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```csharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```javascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\n```javascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\n```javascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(`/login`)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = `https://${link}`\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n```\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```python\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```python\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```python\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n```\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```scala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `java.xml.validation` package:\n\n```scala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\n```scala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```go\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```go\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\n```go\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\n```php\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n```\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\n```php\n<?php\nlibxml_disable_entity_loader(true);\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\n```php\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n```\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**."
              },
              "name": "EnsureNoSecurityGroupsAllowEgressFrom0.0.0.0",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1"
              }
            },
            {
              "id": "ssrf-attacker",
              "help": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njava\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the javax.xml.validation package:\n\njava\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\njava\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\ngmaps-api-net library:\n\ncsharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ncsharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\ncsharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njavascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\njavascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\njavascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(/login)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = https://${link}\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\npython\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\npython\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\npython\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\nscala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the java.xml.validation package:\n\nscala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\nscala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\ngo\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ngo\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\ngo\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\nphp\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\nphp\n<?php\nlibxml_disable_entity_loader(true);\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\nphp\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**.",
                "markdown": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```java\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `javax.xml.validation` package:\n\n```java\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```java\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\n`gmaps-api-net` library:\n\n```csharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```csharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```csharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```javascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\n```javascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\n```javascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(`/login`)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = `https://${link}`\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n```\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```python\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```python\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```python\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n```\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```scala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `java.xml.validation` package:\n\n```scala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\n```scala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```go\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```go\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\n```go\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\n```php\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n```\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\n```php\n<?php\nlibxml_disable_entity_loader(true);\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\n```php\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n```\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**."
              },
              "name": "Server-sideRequestForgery",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Server-Side Request Forgery"
              }
            },
            {
              "id": "CKV_AWS_24",
              "help": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njava\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the javax.xml.validation package:\n\njava\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\njava\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\ngmaps-api-net library:\n\ncsharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ncsharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\ncsharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njavascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\njavascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\njavascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(/login)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = https://${link}\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\npython\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\npython\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\npython\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\nscala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the java.xml.validation package:\n\nscala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\nscala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\ngo\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ngo\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\ngo\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\nphp\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\nphp\n<?php\nlibxml_disable_entity_loader(true);\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\nphp\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**.",
                "markdown": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```java\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `javax.xml.validation` package:\n\n```java\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```java\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\n`gmaps-api-net` library:\n\n```csharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```csharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```csharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```javascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\n```javascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\n```javascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(`/login`)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = `https://${link}`\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n```\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```python\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```python\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```python\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n```\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```scala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `java.xml.validation` package:\n\n```scala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\n```scala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```go\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```go\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\n```go\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\n```php\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n```\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\n```php\n<?php\nlibxml_disable_entity_loader(true);\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\n```php\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n```\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**."
              },
              "name": "EnsureNoSecurityGroupsAllowIngressFrom0.0.0.0",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure no security groups allow ingress from 0.0.0.0:0 to port 22"
              }
            },
            {
              "id": "CKV_AWS_130",
              "help": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njava\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the javax.xml.validation package:\n\njava\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\njava\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\ngmaps-api-net library:\n\ncsharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ncsharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\ncsharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\njavascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\njavascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\njavascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(/login)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = https://${link}\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\npython\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\npython\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\npython\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\nscala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the java.xml.validation package:\n\nscala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\nscala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\ngo\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\ngo\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\ngo\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\nphp\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\nphp\n<?php\nlibxml_disable_entity_loader(true);\n\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\nphp\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**.",
                "markdown": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability.\n\n# Server-Side Request Forgery\n\nA **server-side request forgery** (SSRF) attack is when an attacker crafts a malicious HTTP request that triggers a\nfurther request from your server to a domain of their choosing. SSRF vulnerabilities can be used to probe your network or\nto disguise denial-of-service attacks against third parties.\n\n## Common Causes of SSRF\n\nThere are many reasons your web-server might make outgoing HTTP requests, including:\n\n* Calling a third-party API in response to a user action.\n* Communicating with a *Single Sign-On* (SSO) provider.\n* Implementing an image upload functions that accept URLs instead of files.\n* Checking validation URLs - for example, hosted schema files referenced in XML documents.\n* Accessing open-graph meta-data used in generating link previews.\n\nIn some of these scenarios, the domain of the URL will be taken from the HTTP request. This allows an attacker to \ntrigger HTTP requests to arbitrary domains. Malicious users will try to use this in denial-of-service attacks against \nother targets (for which you will get blamed), and to probe internal IP addresses on your network that are not\nintended to be public.\n\n::::tabs\n\n:::tab[Java]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```java\ncom.google.maps.model.DirectionsResult result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await();\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `javax.xml.validation` package:\n\n```java\nSchemaFactory factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\");\nSchema        schema    = factory.newSchema();\nValidator     validator = schema.newValidator();\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```java\npublic class LinkMetaDataFetcher\n{\n    public static Map<String, String> getMetaData(String link) throws IOException\n    {\n        // Make sure the URL has a protocol.\n        if (!link.startsWith(\"http\")) {\n            link = \"https://\" + link;\n        }\n\n        URL url = new URL(link);\n\n        // Confirm this is a domain not an IP address.\n        if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid domain\");\n        }\n\n        // Be suspicious of anything that supplies a port.\n        if (url.getPort() != -1) {\n            throw new IllegalArgumentException(\"Invalid port\");\n        }\n\n        // Check the block list of forbidden sites.\n        if (BLOCKLIST.contains(url.getHost())) {\n            throw new IllegalArgumentException(\"Invalid link\");\n        }\n\n        // Download the meta-data and convert it to JSON.\n        org.jsoup.nodes.Document doc = org.jsoup.Jsoup.connect(url.toString()).get();\n\n        Map<String, String> meta = new HashMap<>();\n\n        for (org.jsoup.nodes.Element tag : doc.select(\"meta[property^=og:]\")) {\n            meta.put(tag.attr(\"property\"), tag.attr(\"content\"));\n        }\n\n        return meta;\n    }\n}\n```\n\n:::\n\n:::tab[C#]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use a Google Maps SDK like the\n`gmaps-api-net` library:\n\n```csharp\nGoogleSigned.AssignAllServices(new GoogleSigned(\"YOUR_API_KEY\"));\n\nvar request = new GeocodingRequest();\nrequest.Address = \"1600 Pennsylvania Ave NW, Washington, DC 20500\";\n\nvar response = new GeocodingService().GetResponse(request);\nvar result   = response.Results.First();\n\nConsole.WriteLine(result.FormattedAddress);            // \"1600 Pennsylvania Ave NW, Washington, DC 20500, USA\"\nConsole.WriteLine(result.Geometry.Location.Latitude);  // 38.8976633\nConsole.WriteLine(result.Geometry.Location.Longitude); // -77.0365739\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```csharp\nXmlReaderSettings settings = new XmlReaderSettings();\n\nsettings.Schemas.Add(\"https://www.example.com/schema\", \"schema.xsd\");\nsettings.ValidationType = ValidationType.Schema;\nsettings.ValidationEventHandler += new ValidationEventHandler(validationCallback);\n\nXmlReader xml = XmlReader.Create(\"exmaple.xml\", settings);\n\n// Will validate the file 'example.xml' against the schema 'schema.xsd'\nwhile (xml.Read()) { }\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```csharp\n[HttpGet]\npublic IActionResult Preview(string url)\n{\n    var uri = new Uri(url);\n\n    if (uri.IsFile || !uri.IsAbsoluteUri || !uri.IsDefaultPort || uri.Scheme != \"https\")\n    {\n        return BadRequest(\"Please supply a valid HTTPS url.\");\n    }\n    \n    IPAddress address;\n    if (IPAddress.TryParse(uri.Host, out address))\n    {\n        return BadRequest(\"URLs must reference a web domain rather than an IP address.\");\n    }\n\n    if (!Blocklist.Contains(uri.Host))\n    {\n        return BadRequest(\"This domain is block-listed.\");\n    }\n\n    var graph = OpenGraph.ParseUrl(url);\n\n    return Json(graph.Metadata);\n}\n```\n\n:::\n\n:::tab[JavaScript]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```javascript\nconst { GoogleMaps } = require(\"@googlemaps/google-maps-services-js\")\n\nconst maps = new GoogleMaps({});\n\n// This will make an HTTPS request to the Google Maps APi,\n// ensuring the domain (and URL) are constructed safely.\nmaps.elevation({\n    params: {\n      locations: [{ lat: 45, lng: -110 }],\n      key: process.env.GOOGLE_MAPS_API_KEY,\n    },\n    timeout: 1000\n  })\n  .then((response) => {\n    // Do something with the response.\n  })\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\n```javascript\nconst validator = require('xsd-schema-validator')\n\n// Validate the XML file against a scheme file in the local /resources directory.\nvalidator.validateXML(xml, 'resources/schema.xsd', (error, result) => {\n  if (error) {\n    throw error;\n  }\n\n  if (result.valid) {\n    // Continue processing.\n  }\n})\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\n```javascript\nconst urlMetadata = require('url-metadata')\nconst express     = require('express')\nconst app         = express()\n\nfunction authenticated(request, response, next) {\n  if (!request.session || !request.session.user) {\n    return response.redirect(`/login`)\n  }\n\n  next()\n}\n\nconst throttle = require(\"express-rate-limit\")\n\n// Only allow 10 links to be shared from a given IP address every minute.\napp.use(\"/share/\", throttle({\n  windowMs: 60 * 1000,\n  max: 10\n}))\n\napp.get('/share', authenticated,(request, response) => {\n  let link = request.params.link.toLowerCase()\n\n  // Make sure the URL has a protocol.\n  if (!link.startsWith('http')) {\n    link = `https://${link}`\n  }\n\n  const url = new URL(link)\n\n  // Confirm this is a domain not an IP address by checking the hostname\n  // ends with a two-letter or three-letter domain.\n  if (!url.hostname.match(/[a-zA-Z]{2,3}$/)) {\n    return response.status(400)\n  }\n\n  // Be suspicious of anything that supplies a port.\n  if (url.port) {\n    return response.status(400)\n  }\n\n  // Check the block list of forbidden sites.\n  if (BLOCKLIST.contains(url.hostname)) {\n    return response.status(400)\n  }\n\n  // Download the metadata for this URL.\n  urlMetadata(url.toString()).then(\n    (metadata) => {\n      response.json(metadata)\n    },\n    (error) => {\n      log.error('Error generating link preview: ' + error)\n      response.status(400)\n    })\n```\n\n:::\n\n:::tab[Python]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```python\nimport googlemaps\nfrom datetime import datetime\n\ngmaps = googlemaps.Client(key=GOOGLE_MAPS_API_KEY)\n\ndirections = gmaps.directions(\"Sydney Town Hall\",\n                              \"Parramatta, NSW\",\n                              mode           = \"transit\",\n                              departure_time = datetime.now())\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```python\nfrom lxml import etree\n\ndef is_validate(xml_file, xsd_file):\n  \"\"\"Validate an XML file at the supplied path against an XSD schema file,\n  disabling external network access.\"\"\"  \n  parser = etree.XMLParser(resolve_entities=False, no_network=True)\n  xml    = etree.parse(xml_file, parser)\n  xsd    = etree.parse(xsd_file, parser)\n  schema = etree.XMLSchema(xsd.getroot()) \n  \n  return schema.validate(xml)\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n\nBelow is an illustration of some of these techniques:\n\n```python\nimport re\nimport validators\n\nfrom flask import Flask\nfrom flask_limiter import Limiter\nfrom flask_limiter.util import get_remote_address\nfrom IPy import IP\nfrom opengraph import OpenGraph\nfrom urllib.parse import urlparse\n\napp = Flask()\n\nlimiter = Limiter(\n  app,\n  key_func       = get_remote_address,\n  default_limits = [ \"200 per day\", \"50 per hour\" ]\n)\n\n@app.route('/share/<url>')\n@limiter.limit\ndef share(link):\n  \"\"\"Return the meta-data for a web-link shared by a user, throttling\n  access by the remote IP address, and validating the link before\n  accessing it.\"\"\"\n\n  # Add a protocol if not supplied.\n  link = link.lower()\n  link = link if re.match(\"^[a-z]+://.*\", link) else f\"https://{link}\"\n\n  # Reject invalid URLs or those containing private IP addresses.\n  if validators.url(link, public=True):\n    raise Exception(\"Invalid or private URL\")\n\n  components = urlparse(link)\n\n  # Reject URLs with non-standard protocols.\n  if components.scheme not in ('http', 'https'):\n    raise Exception(\"Invalid protocol\")\n\n  # Reject URLs with non-standard ports.\n  if ':' in components.netloc:\n    raise Exception(\"Please do not specify a port\")\n\n  # Reject URLs containing IP addresses rather than domains.\n  try:\n    IP(str)\n    raise Exception(\"Please specify domains rather than IP addresses\")\n  except ValueError:\n    pass\n\n  # Reject URLs where the domain is in our blocklist.\n  if components.netloc in BLOCKLIST:\n    raise Exception(\"Please do not share links to this domain\")\n\n  # Everything looks good, go grab the meta-data.\n  return OpenGraph(url=link).to_json()\n```\n\n:::\n\n:::tab[Scala]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```scala\nval result =\n    com.google.maps.DirectionsApi.newRequest(ctx)\n        .mode(com.google.maps.model.TravelMode.BICYCLING)\n        .avoid(\n            com.google.maps.DirectionsApi.RouteRestriction.HIGHWAYS,\n            com.google.maps.DirectionsApi.RouteRestriction.TOLLS,\n            com.google.maps.DirectionsApi.RouteRestriction.FERRIES)\n        .region(\"au\")\n        .origin(\"Sydney\")\n        .destination(\"Melbourne\")\n        .await()\n```\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an attacker.\n\nHere's how to disable external schema validation in the `java.xml.validation` package:\n\n```scala\nval factory   = SchemaFactory.newInstance(\"http://www.w3.org/2001/XMLSchema\")\nval schema    = factory.newSchema()\nval validator = schema.newValidator()\n\nvalidator.setProperty(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\")\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n* Talk to your networking team about limiting which internal servers are reachable from your web-servers.\n* Validate that the URLs contain web domains rather than IP addresses.\n\nNote that a competent attacker will be able to set up DNS records pointing to private IPs, so simply validating a URL\ncontains a domain name (rather than an IP address) generally isn't sufficient.\n \n\nBelow is an illustration of some of these techniques:\n\n```scala\ndef getMetaData(link : String ) = {\n\n    // Make sure the URL has a protocol.\n    if (!link.startsWith(\"http\")) {\n        link = s\"https://$link\"\n    }\n\n    val url = new URL(link)\n\n    // Confirm this is a domain not an IP address.\n    if (!org.apache.commons.validator.routines.DomainValidator.getInstance().isValid(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid domain\")\n    }\n\n    // Be suspicious of anything that supplies a port.\n    if (url.getPort != -1) {\n        throw new IllegalArgumentException(\"Invalid port\")\n    }\n\n    // Check the block list of forbidden sites.\n    if (BlockList.contains(url.getHost) {\n        throw new IllegalArgumentException(\"Invalid link\")\n    }\n\n    // Download the meta-data and convert it to JSON.\n    val doc = org.jsoup.Jsoup.connect(url.toString).get\n\n    val meta = Map()\n\n    for (tag <- doc.select(\"meta[property^=og:]\")) {\n        meta.put(tag.attr(\"property\"), tag.attr(\"content\"))\n    }\n\n    return meta\n}\n```\n\n:::\n\n:::tab[Go]\n\n## Mitigation\n\nThe easiest way to mitigate SSRF vulnerabilities is to never make outgoing HTTP requests to domain names drawn from an incoming HTTP\nrequest. If you call the Google Maps API from your web-server, for instance, the domain of the API should be defined in\nserver-side code, rather than pulled from the client. An easy way to do this is to use the Google Maps SDK:\n\n```go\nimport (\n  \"fmt\"\n  \"googlemaps.github.io/maps\"\n)\n\nfunc main() {\n  client, _ := maps.NewClient(maps.WithAPIKey(\"GOOGLE_MAPS_API_KEY\"))\n  request := &maps.DirectionsRequest{\n    Origin:      \"Sydney\",\n    Destination: \"Perth\",\n  }\n  route, _, err := client.Directions(context.Background(), request)\n  fmt.Println(route)\n}\n```\n\n## Validation URLs\n\nXML documents often reference schema files hosted on remote URLs. Generally speaking, however, you should know how to \nvalidate an uploaded XML file ahead of time. If you perform validation of XML documents on your server, make sure it is \nagainst a schema file stored locally, rather than drawn from an uploaded XML file that could be controlled by an \nattacker:\n\n```go\nimport \"github.com/terminalstatic/go-xsd-validate\"\n\nfunc main() {\n  xsdvalidate.Init()\n  defer xsdvalidate.Cleanup()\n  \n  xsdhandler, _ := xsdvalidate.NewXsdHandlerUrl(\"examples/schema.xsd\", xsdvalidate.ParsErrDefault)\n  defer xsdhandler.Free()\n  \n  xmlFile, _ := os.Open(\"examples/file.xml\")\n  defer xmlFile.Close()\n  \n  xml, _ := ioutil.ReadAll(xmlFile)\n  \n  xmlhandler, _ := xsdvalidate.NewXmlHandlerMem(xml, xsdvalidate.ParsErrDefault)\n  defer xmlhandler.Free()\n  \n  err := xsdhandler.Validate(xmlhandler, xsdvalidate.ValidErrDefault)\n  if err != nil {\n    switch err.(type) {\n      case xsdvalidate.ValidationError:\n        fmt.Println(err)\n      default:\n        fmt.Println(err)\n    }\n  }\n}\n```\n\n## Making Outbound HTTP Requests to Arbitrary URLs\n\nSome websites do need to make requests to arbitrary third-party URLs. Social media sites, for example, allow sharing of\nweb links, and will often pull down the open graph meta-data from those URLs to generate link previews. In these cases,\nyou need to protect yourself against SSRF attacks. This means you should:\n\n* Only make outgoing HTTP requests from your server in response to actions by *authenticated* users.\n* Validate that HTTP requests are only made to publicly accessible URLs.\n* Limit the number of links a user can share in a given time-frame, to avoid abuse.\n* Consider making the user pass a CAPTCHA test with each link they share.\n* Keep a configurable \"blocklist\" of domains you will never contact.\n\nBelow is an illustration of some of these techniques:\n\n```go\nimport (\n  \"fmt\"\n  \"github.com/dyatlov/go-opengraph/opengraph\"\n  \"net/http\"\n  \"net/url\"\n)\n\nfunc share(response http.ResponseWriter, request *http.Request) {\n  request.ParseForm()\n  \n  link := request.Form.Get(\"url\")\n\n  parsedURL, err := url.Parse(link)\n\n  if err != nil {\n    http.Error(response, \"Invalid URL\", http.StatusBadRequest)\n    return\n  }\n\n  if parsedURL.Scheme != \"http\" && parsedURL.Scheme != \"https \" {\n    http.Error(response, \"Invalid scheme\", http.StatusBadRequest)\n    return\n  }\n\n  if Blocklist[parsedURL.Hostname()] {\n    http.Error(response, \"Please do not share links to this site\", http.StatusBadRequest)\n    return\n  }\n\n  // Use a custom TCP dialler to ensure we only contact publicly accessible IP addresses.\n  safeDialer := &net.Dialer{\n    Control: safeSocketControl,\n  }\n\n  safeTransport := &http.Transport{\n    Proxy:             http.ProxyFromEnvironment,\n    DialContext:       safeDialer.DialContext,\n    ForceAttemptHTTP2: true,\n  }\n\n  safeClient := &http.Client{\n    Transport: safeTransport,\n  }\n\n  html, err := safeClient.Get(link)\n\n  if err != nil {\n    http.Error(response, \"Error fetching URL\", http.StatusBadRequest)\n    return\n  }\n\n  meta := opengraph.NewOpenGraph()\n  err = meta.ProcessHTML(html.Body)\n\n  if err != nil {\n    http.Error(response, \"Error parsing meta-data\", http.StatusBadRequest)\n    return\n  }\n\n  json, _ := meta.ToJSON()\n\n  response.Header().Set(\"Content-Type\", \"application/json\")\n  response.Write(json)\n}\n\n// safeSocketControl controls the outgoing TCP connections to ensure they are not\n// contacting internal network addresses.\nfunc safeSocketControl(network string, address string, conn syscall.RawConn) error {\n  if !(network == \"tcp4\" || network == \"tcp6\") {\n    return fmt.Errorf(\"%s is not a safe network type\", network)\n  }\n\n  host, port, err := net.SplitHostPort(address)\n  if err != nil {\n    return fmt.Errorf(\"%s is not a valid host/port pair: %s\", address, err)\n  }\n\n  ipaddress := net.ParseIP(host)\n  if ipaddress == nil {\n    return fmt.Errorf(\"%s is not a valid IP address\", host)\n  }\n\n  if !isPublicIPAddress(ipaddress) {\n    return fmt.Errorf(\"%s is not a public IP address\", ipaddress)\n  }\n\n  if !(port == \"80\" || port == \"443\") {\n    return fmt.Errorf(\"%s is not a safe port number\", port)\n  }\n\n  return nil\n}\n```\n\n:::\n\n:::tab[PHP]\n\n## Mitigation\n\nThe simplest strategy to prevent SSRF attacks is to avoid making HTTP requests to URLs and domains provided through user input. If your server needs to interact with external APIs, the domain names should be hard-coded or configured securely on the server, not obtained from client-side inputs. \n\nFor instance, if you're integrating with the Google Maps API, rather than accepting a URL from the client, use a well-known endpoint through a PHP library or SDK.\n\n```php\n<?php\n// Assuming you're using a Google Maps client library\n$directions = $googleMaps->directions([\n    'origin'      => 'Sydney',\n    'destination' => 'Melbourne',\n    'mode'        => 'bicycling',\n    'avoid'       => ['highways', 'tolls', 'ferries'],\n    'region'      => 'au'\n]);\n```\n\nWhen working with XML files that reference external schemas, ensure validation against a locally stored schema file instead of relying on URLs within the XML file, which might be manipulated by an attacker.\n\nHere's how you can disable external entity loading in libxml, used with PHP's SimpleXML or DOMDocument:\n\n```php\n<?php\nlibxml_disable_entity_loader(true);\n```\n\n### Making Outbound HTTP Requests to Arbitrary URLs\n\nCertain applications do require the capability to make requests to arbitrary URLs, such as social media platforms that generate link previews. In such cases, defensive measures against SSRF attacks are critical. Consider the following:\n\n* URL-escape any dynamic inputs that you use as part of the URL.\n* Only allow outbound requests in the context of actions performed by authenticated users.\n* Impose restrictions on the frequency of link sharing by users to prevent misuse.\n* Implement CAPTCHA mechanisms for each link sharing action, deterring automated abuses.\n* Maintain an updatable \"allowlist\" of domains that your server is allowed to contact, and block requests to unexpected domain names.\n* Collaborate with network administrators to create barriers preventing your web servers from accessing sensitive internal IP ranges.\n* Disable HTTP redirect handling, or else ensure that all the safe-guards for outgoing requests also apply to the new target URL after redirection.\n\nIt's important to note that savvy attackers can exploit DNS records to resolve private IPs through seemingly harmless domain names, making URL validation an insufficient standalone safeguard.\n\nThe following example demonstrates how to apply some of these recommendations:\n\n```php\n<?php\nfunction fetchLinkMetaData($url, $params)\n{\n    // Ensure that dynamic parts of the URL are all URL-encoded\n    if (!isempty($params)) {\n        $url = $url . '?' . http_build_query($params);\n    }\n\n    // Ensure the URL includes a protocol\n    if (!preg_match('#^https?://#i', $url)) {\n        $url = 'https://' . $url;\n    }\n\n    $host = parse_url($url, PHP_URL_HOST);\n\n    // Be wary of URLs specifying a port\n    if (parse_url($url, PHP_URL_PORT)) {\n        throw new Exception('Invalid port');\n    }\n\n    // Consult a allowlist to avoid untrusted domains\n    if (!in_array($host, $ALLOWLIST)) {\n        throw new Exception('Unknown domain');\n    }\n\n    // Retrieve and process the link's metadata\n    $ch = curl_init($url);\n    curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);\n    $response = curl_exec($ch);\n    curl_close($ch);\n\n    // Here, you might parse the HTML response to extract metadata (e.g., Open Graph tags)\n    // and return that data as an associative array or object.\n\n    // This is a simplified response; actual metadata extraction is needed here.\n    return $response;\n}\n?>\n```\n\n:::\n\n::::\n\n## Additional information\n\n**[CWE-918](https://cwe.mitre.org/data/definitions/918.html)**\n\n**[OWASP-A5](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A5-Broken_Access_Control)**\n\n**[OWASP Description of SSRF](https://owasp.org/www-community/attacks/Server_Side_Request_Forgery)**."
              },
              "name": "EnsureVpcSubnetsDoNotAssignPublicIpByDefault",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "warning"
              },
              "fullDescription": {
                "text": "Attacker-Controlled data is used in a URL for an outgoing request without appropriate validation. This indicates a server-side request forgery (SSRF) vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Ensure VPC subnets do not assign public IP by default"
              }
            },
            {
              "id": "sql-injection-attacker-controlled",
              "help": {
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\njava\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\njava\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n\n\nThe key difference is the data being passed to the executeQuery(...) method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as '; drop table users--,\nthey will be able to delete the users table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\ncsharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\ncsharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n\n\nThe key difference is the data being passed to the SqlCommand object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as '; drop table users--,\nthey will be able to delete the users table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the mysql module using a parameterized statement would be:\n\njavascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\njavascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n\n\nThe key difference is the data being passed to the query(...) method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as\n'; DROP TABLE users--, they will be able to delete the users table altogether, since the executed SQL statement will\nbe:\n\nsql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the mysql module as follows:\n\njavascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the sqlstring library to safely encode the query:\n\njavascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n\n\n### PostgreSQL\n\nTo run a parameterized statement with the node-postgres module:\n\njavascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the pg-format library to safely encode the query:\n\njavascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the tedious module:\n\njavascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the oracldb module:\n\njavascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the sqlite3 module:\n\njavascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\npython\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\npython\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n\n\nThe key difference is the data being passed to the execute(...) method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as '; drop table users--,\nthey will be able to delete the users table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\npython\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n\n\n### PostgreSQL\n\npython\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n\n\n### SQLite\n\npython\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n\n\n### SQL Server\n\npython\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n\n\n### Oracle\n\npython\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\nscala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\nscala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n\n\nThe key difference is the data being passed to the executeQuery(...) method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as '; drop table users--,\nthey will be able to delete the users table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\ngo\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\ngo\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n\n\nThe key difference is the data being passed to the db.Query(...) method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the email parameter value as '; drop table users--,\nthey will be able to delete the users table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\nphp\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\nphp\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the email input to modify the SQL statement. For instance, by providing an email input like '; DELETE FROM users; --, they could potentially delete all records in the users table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like mysqli_real_escape_string to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**.",
                "markdown": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability.\n\n# SQL Injection\n\n**SQL injection** is a type of *injection attack*. Injection attacks occur when maliciously crafted inputs are submitted\nby an attacker, causing an application to perform an unintended action. In a SQL injection attack, untrusted input from\nthe HTTP request or frontend is inserted into a SQL statement insecurely, allowing an attacker to run arbitrary commands\non the  database. This allows an attacker to steal and manipulate sensitive data, or inject other malicious code that\ncan be used to escalate their attack.\n\nIn most applications, SQL statements are defined in the codebase or configuration, then executed according to a set of\nparameters passed in from an external source. You should use *parameterized statements* to ensure these parameters are\n*bound* to the SQL statement securely, so attackers cannot inject extra SQL statements or change the logic of an\nexisting statement.\n\n::::tabs\n\n:::tab[Java]\n\n## Parameterized Statements in Java\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(DATABASE_URL, DATABASE_USERNAME, DATABASE_PASSWORD);\n\n// Construct the SQL statement we want to run, specifying the parameter.\nString sql = \"SELECT * FROM users WHERE email = ?\";\n\n// Generate a prepared statement with the placeholder parameter.\nPreparedStatement statement = connection.prepareStatement(sql);\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email);\n\n// Run the query...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```java\n// Connect to the database.\nConnection connection = DriverManager.getConnection(URL, USER, PASS);\nStatement statement = connection.createStatement();\n\n// Bad, bad news! Don't construct the query with string concatenation.\nString sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\n// When this query gets run...\nResultSet results = statement.executeQuery(sql);\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[C#]\n\n## Parameterized Statements in C#\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = @Email\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    \n    command.Parameters.Add(new SqlParameter(\"@Email\", System.Data.SqlDbType.VarChar));\n    command.Parameters[\"@Email\"].Value = email;\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            // Process user data.\n        }\n    }\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```csharp\nstring queryString = \"SELECT * FROM users WHERE email = '\" + email + \"'\";\n\nusing (var connection = new SqlConnection(connectionString))\n{\n    SqlCommand command = new SqlCommand(queryString, connection);\n    connection.Open();\n    \n    using (SqlDataReader reader = command.ExecuteReader())\n    {\n        while (reader.Read())\n        {\n            \n        }\n    }\n}\n```\n\nThe key difference is the data being passed to the `SqlCommand` object. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[JavaScript]\n\n## Parameterized Statements in JavaScript\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nIn JavaScript, the database driver you use will depend on which database you are communicating with. For example, a\nsecure way of running a SQL query using the `mysql` module using a parameterized statement would be:\n\n```javascript\nconst email      = 'user@email.com'\nconst mysql      = require('mysql')\nconst connection = mysql.createConnection({\n  host     : 'localhost',\n  user     : 'admin',\n  password : 'password',\n  database : 'database'\n});\n\nconnection.connect(() => { })\n\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nContrast this to explicit construction of the SQL string, which is **very, very dangerous**:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = \"' + email + \"'\", (error, results, fields) => {\n\n})\n```\n\nThe key difference is the data being passed to the `query(...)` method. In the first case the parameterized\nquery and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as\n`'; DROP TABLE users--`, they will be able to delete the `users` table altogether, since the executed SQL statement will\nbe:\n\n```sql\nSELECT * FROM users WHERE email = ''; DROP TABLE users--'\n```\n\n### MySQL\n\nAs illustrated above, you run a parameterized statement with the `mysql` module as follows:\n\n```javascript\nconnection.query('SELECT * FROM users WHERE email = ?', [ email ], (error, results, fields) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `sqlstring` library to safely encode the query:\n\n```javascript\nconst sqlstring  = require('sqlstring')\nconst escapedSql = sqlstring.format(\n                     'SELECT * FROM ?? WHERE ?? = ?',\n                     [ 'users', 'email', email ]\n                   )\n\nconnection.query(escapedSql, (error, results, fields) => {\n\n})\n```\n\n### PostgreSQL\n\nTo run a parameterized statement with the `node-postgres` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst { Client } = require('pg')\nconst client     = new Client()\n\nclient.connect()\n\nclient.query('SELECT * FROM users WHERE email = $1', [ email ], (err, res) => {\n\n})\n```\n\nIf you need to dynamically insert e.g. table names in a query, they can't be passed as bind parameters. Instead, you\nshould use the `pg-format` library to safely encode the query:\n\n```javascript\nconst format     = require('pg-format')\nconst escapedSql = format('SELECT * FROM %I WHERE %I = %L', 'users', 'email', email)\n\nclient.query(escapedSql, (err, res) => {\n\n})\n```\n\n### SQL Server\n\nTo run a parameterized statement against a Microsoft SQL Server database with the `tedious` module:\n\n```javascript\nconst email      = \"user@email.com\"\nconst Connection = require('tedious').Connection;\nconst config = {\n  server: 'localhost',  \n  authentication: {\n    type: 'default',\n    options: {\n      password: 'password' \n    }\n  },\n  options: {\n    encrypt: true,\n    database: 'database'  \n  }\n}\nconst connection = new Connection(config)\n\nconnection.connect()\n\nconst Request = require('tedious').Request\nconst TYPES   = require('tedious').TYPES\nconst request = new Request('SELECT * FROM users WHERE email = @email')\n\nrequest.addParameter('email', TYPES.NVarChar, email)\n\nrequest.on('row', (columns) => {\n\n})\n\nrequest.on(\"requestCompleted\", (rowCount, more) => {\n  connection.close()\n})\n\nconnection.execSql(request)\n```\n\n### Oracle\n\nTo run a parameterized statement against am Oracle database with the `oracldb` module:\n\n```javascript\nconst email      = 'user@email.com'\nconst oracledb = require('oracledb')\n\nconnection = await oracledb.getConnection( {\n  user          : \"admin\",\n  password      : \"password\",\n  connectString : \"localhost/database\"\n})\n\nconst result = await connection.execute(\n  'SELECT * FROM users WHERE email = :1',\n  email\n)\n```\n\n### SQLite\n\nTo run a parameterized statement against a SQLite database with the `sqlite3` module:\n\n```javascript\nconst sqlite3 = require('sqlite3').verbose()\nconst db      = new sqlite3.Database(':memory:')\n\ndb.serialize(() => {\n  db.run(\"CREATE TABLE users (email TEXT)\")\n\n  const statement = db.prepare(\"INSERT INTO users VALUES (?)\")\n  statement.run(email)\n  statement.finalize()\n\n  db.each(\"SELECT * FROM users WHERE email = ?\", [email], (err, row) => {\n\n  })\n\n  db.close()\n})\n```\n\n:::\n\n:::tab[Python]\n\n## Parameterized Statements in Python\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Construct the SQL statement we want to run, specifying the parameter.\n    sql = \"SELECT * FROM users WHERE email = %(email)s\"\n\n    # Execute the SQL passing in a parameter to bind.\n    cursor.execute(sql, dict(email=email))\n\n    for result in cursor.fetchone():\n      # Do something with the data returned.\n      pass\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n\n    # Bad, bad news! Don't construct the query with string concatenation.\n    sql = \"SELECT * FROM users WHERE email = '\" + email + \"'\"\n\n    # When this query gets run...\n    cursor.execute(sql)\n\n    for result in cursor.fetchone():\n      # ...an attacker may have compromised your database.\n      pass\n```\n\nThe key difference is the data being passed to the `execute(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\nBelow are examples of how use parameterized statements in the major database drivers. Since most database drivers\nimplement the Python Database API Specification (PEP-249), they look very similar.\n\n### MySQL\n\n```python\nimport pymysql.cursors\n\nconnection = pymysql.connect(**MYSQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### PostgreSQL\n\n```python\nimport psycopg2\n\nconnection = psycopg2.connect(**POSTGRESQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQLite\n\n```python\nimport sqlite3\n\nconnection = sqlite3.connect(SQLITE_DATABASE_NAME)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### SQL Server\n\n```python\nimport pymssql\n\nconnection = pymssql.connect(**MS_SQL_CONNECTION_DETAILS)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n### Oracle\n\n```python\nimport cx_Oracle as oracledb\n\nconnection = oracledb.connect(ORACLE_DB_CONNECTION_STRING)\n\nwith connection:\n  with connection.cursor() as cursor:\n    cursor.execute('SELECT * FROM users WHERE email = %(email)s', dict(email=email))\n\n    for result in cursor.fetchone():\n      pass\n```\n\n:::\n\n:::tab[Scala]\n\n## Parameterized Statements in Scala\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. Parameterized statements make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in JDBC using a parameterized statement would be:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\n\n// Construct the SQL statement we want to run, specifying the parameter.\nval sql = \"SELECT * FROM users WHERE email = ?\"\n\n// Generate a prepared statement with the placeholder parameter.\nval statement = connection.prepareStatement(sql)\n\n// Bind the \"email\" value into the statement at parameter index 1.\nstatement.setString(1, email)\n\n// Run the query...\nval results = statement.executeQuery(sql)\n\nwhile (results.next())\n{\n    // ...do something with the data returned.\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```scala\n// Connect to the database.\nval connection = DriverManager.getConnection(DatabaseUrl, DatabaseUsername, DatabasePassword)\nval statement  = connection.createStatement()\n\n// Bad, bad news! Don't construct the query with string interpolation.\nval sql = s\"SELECT * FROM users WHERE email = '$email''\"\n\n// When this query gets run...\nval results = statement.executeQuery(sql)\n\nwhile (results.next()) {\n  // ...an attacker may have compromised your database.\n}\n```\n\nThe key difference is the data being passed to the `executeQuery(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[Go]\n\n## Parameterized Statements in Go\n\nProgramming languages talk to SQL databases using *database drivers.* A driver allows an application to construct and\nrun SQL statements against a database, extracting and manipulating data as needed. *Parameterized statements* make sure\nthat the parameters (i.e. inputs) passed into SQL statements are treated safely.\n\nFor example, a secure way of running a SQL query in MySQL using a parameterized statement would be:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Using bind parameters protects us from SQL injection.\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = ?\", email)\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nContrast this to explicit interpolation of the SQL string, which is **very, very dangerous**:\n\n```go\nimport (\n  \"database/sql\"\n  _ \"github.com/go-sql-driver/mysql\"\n  \"log\"\n  \"os\"\n)\n\nfunc findUser(email string) int {\n  db, err := sql.Open(\"mysql\", os.Getenv(\"DB_CONNECTION_STRING\"))\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer db.Close()\n\n  // Don't use string concatenation to build SQL queries!\n  rows, err := db.Query(\"SELECT * FROM users WHERE email = '\" + email + '\"')\n  if err != nil {\n    log.Fatal(err)\n    return 0\n  }\n\n  defer rows.Close()\n\n  var userId int\n\n  for rows.Next() {\n    err := rows.Scan(&userId)\n\n    if err != nil {\n      log.Fatal(err)\n      return 0\n    }\n\n    return userId\n  }\n\n  return 0\n}\n```\n\nThe key difference is the data being passed to the `db.Query(...)` method. In the first case the parameterized\nstring and the parameters are passed to the database separately, which allows the driver to correctly interpret them.\nIn the second case, the full SQL statement is constructed before the driver is invoked, meaning we are vulnerable to\nmaliciously crafted parameters. For example, if the attacker passes the `email` parameter value as `'; drop table users--`,\nthey will be able to delete the `users` table altogether.\n\n:::\n\n:::tab[PHP]\n\n## Parameterized Statements in PHP\n\nIn PHP, the MySQLi and PDO (PHP Data Objects) extensions provide support for parameterized queries, ensuring that input parameters are securely bound to SQL statements.\n\nHere's a secure way of running a SQL query using PDO with a parameterized statement:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database using PDO.\n$conn = new PDO($dsn, $user, $password);\n\n// Construct the SQL statement with a placeholder parameter.\n$sql = \"SELECT * FROM users WHERE email = :email\";\n\n// Prepare the statement.\n$stmt = $conn->prepare($sql);\n\n// Bind the email value to the placeholder.\n$stmt->bindParam(':email', $email);\n\n// Execute the query.\n$stmt->execute();\n\n// Fetch the results.\nwhile ($row = $stmt->fetch(PDO::FETCH_ASSOC)) {\n    // ...do something with the data returned.\n}\n?>\n```\n\nContrast this with the insecure practice of directly embedding user input into the SQL string, which is **highly discouraged**:\n\n```php\n<?php\n// Database configuration\n$dsn = 'mysql:host=localhost;dbname=testdb';\n$user = 'username';\n$password = 'password';\n\n// Connect to the database.\n$conn = new PDO($dsn, $user, $password);\n\n// This is dangerous! Avoid constructing the query with string concatenation.\n$sql = \"SELECT * FROM users WHERE email = '\" . $email . \"'\";\n\n// Execute the query directly.\nforeach ($conn->query($sql) as $row) {\n    // ...possible compromise if the attacker manipulates the email input.\n}\n?>\n```\n\nIn the first example, the SQL statement and the parameters are sent to the database separately, preventing SQL injection. In the insecure approach, attackers can manipulate the `email` input to modify the SQL statement. For instance, by providing an `email` input like `'; DELETE FROM users; --`, they could potentially delete all records in the `users` table. In rare cases where use of the second approach is unavoidable, escape all dynamic inputs with database-specific functions like `mysqli_real_escape_string` to disarm them.\n\n:::\n\n::::\n\n\n## Other Considerations.\n\n* Use of an *Object-Relational Mapping* library will reduce the amount of SQL statements you have to\n  write in your code, and will push you towards best practice when interacting with the database.\n\n* Connecting to the database under an account with limited permissions - following the *principle of least privilege* -\n  is always a good idea, since it mitigates the harm an attacker can do.\n\n## Additional information\n\n**[CWE-89](https://cwe.mitre.org/data/definitions/89.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**."
              },
              "name": "SqlInjection",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker controlled data is used in a SQL query without undergoing escaping or validation. This indicates a SQL injection vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "SQL Injection"
              }
            },
            {
              "id": "alert-in-production",
              "help": {
                "text": "This application uses the alert() function in production code.\n\nUsing alert() in production code disrupts user experience by halting web page interactions until the user acknowledges the alert. Additionally, alert() is not customizable, leading to inconsistent and unprofessional UI design.\n\n\n## Countermeasures\n\nInstead of alert(), consider using modal dialogs for customizable and integrated alerts, toast notifications for non-intrusive, brief messages, or custom JavaScript alerts for a seamless design that matches your website's style. These alternatives offer enhanced user experience and design consistency.\n\n## Additional information\n\n**[CWE-477](https://cwe.mitre.org/data/definitions/477.html)**.",
                "markdown": "This application uses the `alert()` function in production code.\n\nUsing `alert()` in production code disrupts user experience by halting web page interactions until the user acknowledges the alert. Additionally, `alert()` is not customizable, leading to inconsistent and unprofessional UI design.\n\n\n## Countermeasures\n\nInstead of `alert()`, consider using modal dialogs for customizable and integrated alerts, toast notifications for non-intrusive, brief messages, or custom JavaScript alerts for a seamless design that matches your website's style. These alternatives offer enhanced user experience and design consistency.\n\n## Additional information\n\n**[CWE-477](https://cwe.mitre.org/data/definitions/477.html)**."
              },
              "name": "SecurityBestPractices",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "note"
              },
              "fullDescription": {
                "text": "This application uses the `alert()` function in production code."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Security Best Practices"
              }
            },
            {
              "id": "command-injection-attacker-controlled",
              "help": {
                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\njavax.script page) package allows you to evaluate code in a number of different scripting languages via the \nScriptEngineManager class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the javax.tools.JavaCompiler interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the ScriptingEngine class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\njava\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \nSystem.CodeDom namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the eval(...) function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\njavascript\n  eval(\"console.log('WARNING')\")\n\n\nIf an attacker is able to control the input to an eval(...) call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the Function(...) or\nScript(...) constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\njavascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually Function(...)), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\njavascript\narbitraryObject[parameterA][parameterB](parameterC)()\n\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the eval(...) function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of eval(...) in the Node.js runtime by passing the --disallow-code-generation-from-strings\n  at startup. (You will have to ensure none of your dependencies use the eval(...) function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global eval(...) and exec(...) functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid eval(...) and exec(...) functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \nast (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\npython\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the scala-lang package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\nscala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\nscala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe math-expression-parser library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\nscala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like net/rpc or grpc to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With grpc this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\ngo\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\ngo\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(print(\"hello\")); err != nil {\n    panic(err)\n  }\n}\n\n\nThis example will execute the simple Lua expression print(\"hello\"). Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the sandbox.DoString(...) \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \nsandbox.SetField(...) function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include eval(), system(), exec(), passthru(), shell_exec(), and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\nphp\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n\n\nBy visiting a URL like http://example.com/vulnerable.php?script=system('ls'); an attacker could execute the ls command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\nphp\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like eval() altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**.",
                "markdown": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability.\n\n# Remote Code Execution\n\nA **remote code execution** (RCE) vulnerability allows an attacker to execute arbitrary code on you server. On a\nweb-server, RCE vulnerabilities are typically cause when untrusted input from the HTTP request is evaluated as code.\n\n::::tabs\n\n:::tab[Java]\n\n## Remote Code Execution in Java\n\nDynamic evaluation of code in Java can be achieved in a number of ways. The Java scripting API (defined in the\n`javax.script` page) package allows you to evaluate code in a number of different scripting languages via the \n`ScriptEngineManager` class. There are, for instance, JVM compatible versions of Python (called Jython) and Ruby (called\nJRuby) that can be loaded as jars and invoked via the script manager.\n\nThe Java compiler can also be invoked programmatically via the `javax.tools.JavaCompiler` interface. This approach is\noften used by build tools, which convert files on disk to runnable code that can be loaded into the JVM.\n\nFinally, there are a number of other tools that allow dynamic evaluation of code. The Apache Bean Scripting Framework\na range of scripting languages, and the scripting languages like Groovy can be added to the Java runtime by simply\nadding a jar in the classpath.\n\nWith all of these approaches, it is of vital importance that you only pass trusted code to the scripting API. Passing \nuntrusted content to the `ScriptingEngine` class, for instance,  will allow an attacker to execute arbitrary code in \nyour Java Virtual Machine - meaning they can steal sensitive information, read files from disk, or install malware.\n\nTo secure your code, you should ensure any strings passed to a scripting engine are taken from a trusted source, or \nvalidated against an allow-list:\n\n```java\nprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException \n{\n  String code = request.getParameter(\"script\");\n\n  // Since we are taking the code to execute from an untrusted source (the HTTP\n  // request) we *must* validate against an allowed list of scripts.      \n  if (!allowedCommands.contains(code))\n    throw new IOException(\"Not permitted\");\n\n  ScriptEngineManager manager = new ScriptEngineManager();\n  ScriptEngine        engine  = manager.getEngineByName(\"JavaScript\");\n  engine.eval(input);\n  \n  response.setStatus(200);\n}\n```\n\n## Further Considerations\n\nDynamic code evaluation is often used where there is a need to develop a *Domain Specific Language* (DSL) for expert \nusers. In such a scenario, it is preferable to execute DSL statements in a sandbox with limited permissions. (For\ninstance, you probably want to limit disk and network access if you are simply evaluating mathematical statements.) One\nway to achieve this is by formally defining the grammar of the DSL, and using a tool like Java Compiler Compiler (JavaCC)\nor ANTLR to generate a parser that can evaluate scripts at runtime. Since the grammar specification defines which\nfunctions are executable, you have full control over what the DSL can do.\n\n:::\n\n:::tab[C#]\n\n## Remote Code Execution in C#\n\nC# code can be evaluated dynamically using the Code Document Object Model (CodeDOM) module, defined in the \n`System.CodeDom` namespace. CodeDOM allows for templated code generation and dynamic compilation within the .NET \nruntime.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your C# runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to using the CodeDOM module in applications that face\nthe internet.\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in .NET, consider using one of\nthe following solutions:\n\n* Microsoft's DSL Tools, that come bundled with Visual Studio and allow the visual creation of DSLs.\n* A scripting language like Lua that can be dynamically loaded and executed within the .NET runtime.\n* ANTLR, a parser generator that can be used to generate and execute sand-boxed languages.\n\n:::\n\n:::tab[JavaScript]\n\n## Remote Code Execution in JavaScript Using Eval\n\nJavaScript makes dynamic evaluation of strings as code very easy by making the `eval(...)` function available. For\ninstance, the following JavaScript code will print \"WARNING\" to the console:\n\n```javascript\n  eval(\"console.log('WARNING')\")\n```\n\nIf an attacker is able to control the input to an `eval(...)` call by passing it in an HTTP request, they can run code\non your server. This will allow them to scan your file system, install a remote shell, and take over your server \ncompletely.\n\n## Other Types of Remote Code Execution in JavaScript\n\nInput strings can also be dynamically evaluated as code in the JavaScript runtime using the `Function(...)` or\n`Script(...)` constructors. There are various subtle ways of doing this, as illustrated by the following code:\n\n```javascript\nconst arbitraryObject = {},\n      a = 'constructor',\n      b = 'constructor',\n      s = 'console.log(\"Hacked!\")';\n\n// This will print the phrase 'Hacked!' to the console.\narbitraryObject[a][b](s)()\n```\n\nThese two lines of code illustrate an RCE vulnerability. Properties can be looked up on a JavaScript object by name, \nand this includes functions. The illustrated exploit gets the constructor function for an arbitrary object, looks up \nrhe constructor function for the constructor (which is actually `Function(...)`), passes it a command string, then \nexecutes that string. \n\nAlthough this example is contrived, it illustrates how any code that has the form:\n\n```javascript\narbitraryObject[parameterA][parameterB](parameterC)()\n```\n\n...enables a remote execution attack if all the parameters can be controlled by an attacker.\n\n## Mitigation\n\n* Don't use the `eval(...)` function in your code. Check your codebase with a linter as part of your build process.\n* Consider disabling use of `eval(...)` in the Node.js runtime by passing the `--disallow-code-generation-from-strings`\n  at startup. (You will have to ensure none of your dependencies use the `eval(...)` function to do this.)\n* Validate all untrusted input with allow-lists: check any input take from the HTTP request is safe before processing \n  it.\n* If you make nested lookups on objects, make assertions about object types when pulling them from another object. If\n  your code finds a function where it expects a string, don't invoke it!\n\n:::\n\n:::tab[Python]\n\n## Remote Code Execution in Python\n\nPython code can be evaluated dynamically using the global `eval(...)` and `exec(...)` functions. The former expects\na string representing a (single) valid Python expression, while the later can execute multiple expressions - making it \nable to create new module, class, and function definitions. Both functions have access to the global and local state\nat the point of invocation.\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Python runtime -\nmeaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid `eval(...)` and `exec(...)` functions of Python \naltogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Python, consider using the \n`ast` (*Abstract Syntax Tree*) module, which allows you to parse expressions and evaluate each node atomically. This will\nhelp you \"sandbox\" the functions a user can invoke, removing the risks of arbitrary code execution.\n\nHere's a simple example of a DSL that can evaluate mathematical expressions:\n\n```python\nimport ast, operator, math\n\ndef safe_eval(expression):\n  \"\"\"Evaluate a simple mathematical function by parsing an expression into an\n  abstract syntax tree and safely evaluating each node in turn.\"\"\"\n\n  def find_math_function(x, *args):\n    if x not in [x for x in dir(math) if not \"__\" in x]:\n      raise SyntaxError(f\"Unknown function {x}()\")\n\n    return getattr(math, x)\n\n  binary_operations = {\n    ast.Add:   operator.add,\n    ast.Sub:   operator.sub,\n    ast.Mult:  operator.mul,\n    ast.Div:   operator.truediv,\n    ast.Mod:   operator.mod,\n    ast.Pow:   operator.pow,\n    ast.Call:  find_math_function,\n    ast.BinOp: ast.BinOp,\n  }\n\n  unary_operations = {\n    ast.USub:    operator.neg,\n    ast.UAdd:    operator.pos,\n    ast.UnaryOp: ast.UnaryOp,\n  }\n\n  operations = tuple(binary_operations) + tuple(unary_operations)\n\n  syntax_tree = ast.parse(expression, mode='eval')\n\n  def _eval(node):\n    if isinstance(node, ast.Expression):\n      return _eval(node.body)\n    elif isinstance(node, ast.Str):\n      return node.s\n    elif isinstance(node, ast.Num):\n      return node.value\n    elif isinstance(node, ast.Constant):\n      return node.value\n    elif isinstance(node, ast.BinOp):\n      if isinstance(node.left, operations):\n        left = _eval(node.left)\n      else:\n        left = node.left.value\n      if isinstance(node.right, operations):\n        right = _eval(node.right)\n      else:\n        right = node.right.value\n      return binary_operations[type(node.op)](left, right)\n    elif isinstance(node, ast.UnaryOp):\n      if isinstance(node.operand, operations):\n        operand = _eval(node.operand)\n      else:\n        operand = node.operand.value\n      return unary_operations[type(node.op)](operand)\n    elif isinstance(node, ast.Call):\n      args = [_eval(x) for x in node.args]\n      function = find_math_function(node.func.id)\n      return function(*args)\n    else:\n      raise SyntaxError(f\"Bad syntax, {type(node)}\")\n\n  return _eval(syntax_tree)\n\nsafe_eval(\"1 + 1\")       # Will return 2\nsafe_eval(\"(100*10)+6\")  # Will return 1006\nsafe_eval(\"sqrt(16)+1\")  # Will return 5.0\n```\n\n:::\n\n:::tab[Scala]\n\n## Remote Code Execution in Scala\n\nScala code can be evaluated dynamically using the `scala-lang` package, that will generate bytecode objects to be loaded \ninto the underlying Java Virtual Machine. The following web-application takes a scriptlet from an HTTP parameter and\nevaluates the result:\n\n```scala\ncase class Scriptlet(code: String)\n\ndef scriptExecutionForm = Form(\n  mapping(\n    \"code\" -> text\n  )(Scriptlet.apply)(Scriptlet.unapply)\n)\n\ndef evaluateScript = Action(parse.form(scriptExecutionForm)) { request =>\n  val settings = new Settings\n\n  settings.usejavacp.value   = true\n  settings.deprecation.value = true\n\n  val eval      = new IMain(settings)\n  val evaluated = eval.interpret(request.body.code)\n\n  if (evaluated == Success) {\n    val result = eval.valueOfTerm(\"result\").get.asInstanceOf[String]\n    Ok(result)\n  }\n  else {\n    Status(488)(\"Unable to evaluate this code\")\n  }\n}\n```\n\nAnother common method of achieving dynamic execution in Scala is by using reflection:\n\n```scala\nimport scala.reflect.runtime.universe\nimport scala.tools.reflect.ToolBox\n\nval toolbox = universe.runtimeMirror(getClass.getClassLoader).mkToolBox()\ntoolbox.eval(toolbox.parse(\"\"\"println(\"Hello world\")\"\"\"))\n```\n\nPassing untrusted string as code to be evaluated allows an attacker to execute arbitrary code in your Java Virtual \nMachine - meaning they can steal sensitive information, read files from disk, or install malware. This is very \ndangerous!\n\nTo mitigate remote code execution attacks, you must ensure any strings are taken from a trusted source, or validated \nagainst an allow-list. To be totally secure, it's often better to avoid using dynamic evaluation of Scala altogether. \n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Scala, consider using a\ntoolkit like the Scala Standard Parser Combinator Library, which allows you to write parsers that will \"sandbox\" the \nfunctions a user can invoke, removing the risks of arbitrary code execution.\n\nThe `math-expression-parser` library is good example of a well-scoped DSL that allows evaluation of simple arithmetic\nexpressions:\n\n```scala\nimport io.github.facaiy.math.expression.MathExp\n\nval expressionString = \"1.0 + sqrt(2 * $a1) + $a2 ** 2\"\nval parsedExpression = MathExp.parse(expressionString)\nval inputVariables   = Map(\"a1\" -> 2, \"a2\" -> 1)\n\n// This will return the value \"4.0\", by evaluating the expression with the supplied input variables.\nval output = parsedExpression.eval(inputVariables)\n```\n\n:::\n\n:::tab[Go]\n\n## Remote Code Execution in Go\n\nDynamic execution of Go is relatively rare. The Go playground (https://go.dev/play/) allows you to run Go code from a\nweb browser, and achieves this by dynamically compiling code using the Go toolchain, and executing the compiled code in\na sandbox on a remote server.\n\nMore common is the use of packages like `net/rpc` or `grpc` to allow remote invocation of individual methods across a \nnetwork. This allows a development team to build efficient, distributed micro-services.\n\nTo mitigate remote code execution attacks in a distributed computing environment, you must ensure any procedure calls \ncome from a trusted source. With `grpc` this can be achieved using Application Layer Transport Security (ALTS), a mutual \nauthentication and transport developed by Google:\n\n```go\nimport (\n  \"google.golang.org/grpc\"\n  \"google.golang.org/grpc/credentials/alts\"\n)\n\naltsTC          := alts.NewClientCreds(alts.DefaultClientOptions())\nconnection, err := grpc.Dial(serverAddr, grpc.WithTransportCredentials(altsTC))\n```\n\n## Domain Specific Languages\n\nDynamic evaluation is often used to build *Domain Specific Languages* (DSLs) that allow expert users to write simple\nexpressions that query data or encode business logic. If you find yourself writing a DSL in Go, consider using an \nembeddable scripting language like Lua:\n\n```go\nimport (\n  \"github.com/yuin/gopher-lua\"\n)\n\nfunc main() {\n  // Instantiate a Lua sandbox.\n  sandbox := lua.NewState()\n  \n  defer sandbox.Close()\n  \n  // Dynamically execute a string as Lua code.\n  if err := sandbox.DoString(`print(\"hello\")`); err != nil {\n    panic(err)\n  }\n}\n```\n\nThis example will execute the simple Lua expression `print(\"hello\")`. Using a Lua sandbox in this fashion will allow you \nto execute dynamic expressions passed by a user safely - simply pass the expression to the `sandbox.DoString(...)` \nfunction to execute it. The executed code will *only* be able to access state you pass to the sandbox via the \n`sandbox.SetField(...)` function, closing any security loopholes associated with remote code execution.\n\n:::\n\n:::tab[PHP]\n\n## Remote Code Execution in PHP\n\nPHP provides several functions that allow for the execution of system commands and the evaluation of code dynamically. Some commonly used functions for this purpose include `eval()`, `system()`, `exec()`, `passthru()`, `shell_exec()`, and others.\n\nThis vulnerability arises when developers use these functions without properly validating or sanitizing user inputs. This can allow an attacker to inject and execute arbitrary code on the server.\n\nConsider the following PHP snippet, which takes a script input from an HTTP request and evaluates it:\n\n```php\n<?php\n$script = $_GET['script'];\n\n// Using the eval function directly on unsanitized input poses a severe security risk.\n// An attacker can provide a malicious PHP code as a value for the \"script\" parameter and execute it.\neval($script);\n\necho \"Script executed successfully!\";\n?>\n```\n\nBy visiting a URL like `http://example.com/vulnerable.php?script=system('ls');` an attacker could execute the `ls` command, and with more malicious intent, they can cause significant harm.\n\n## Mitigation\n\nTo secure your code, ensure that strings passed to evaluation or execution functions are from trusted sources, or are validated against an allow-list:\n\n```php\n<?php\n$allowedScripts = ['print_hello' => 'echo \"Hello, World!\";'];\n\n$scriptKey = $_GET['scriptKey'];\n\n// Validate against an allow-list of scripts.\nif (!array_key_exists($scriptKey, $allowedScripts)) {\n    die(\"Not permitted\");\n}\n\neval($allowedScripts[$scriptKey]);\n\necho \"Script executed successfully!\";\n?>\n```\n\n## Further Considerations\n\nDynamic code evaluation in PHP should be used with extreme caution. Whenever possible, avoid using functions like `eval()` altogether. If dynamic functionality is needed, consider more secure alternatives like creating pre-defined safe functions or adopting a Domain-Specific Language (DSL) with strict parsing and validation. Always use PHP's built-in functions to sanitize and validate all user inputs to prevent code injections.\n\n:::\n\n::::\n\n## CWEs\n\n**[CWE-77](https://cwe.mitre.org/data/definitions/77.html)**\n\n**[CWE-78](https://cwe.mitre.org/data/definitions/78.html)**\n\n**[CWE-94](https://cwe.mitre.org/data/definitions/94.html)**\n\n**[CWE-917](https://cwe.mitre.org/data/definitions/917.html)**\n\n**[OWASP-A1](https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A1-Injection)**."
              },
              "name": "RemoteCodeExecution",
              "properties": {
                "tags": [
                  "ng-sast"
                ],
                "precision": "very-high"
              },
              "defaultConfiguration": {
                "level": "error"
              },
              "fullDescription": {
                "text": "Attacker-controlled data is used in a shell command without undergoing escaping or validation. This indicates a command injection vulnerability."
              },
              "helpUri": "https://docs.shiftleft.io/ngsast/product-info/coverage#vulnerabilities",
              "shortDescription": {
                "text": "Remote Code Execution"
              }
            }
          ],
          "version": "1.0.0",
          "fullName": "Qwiet preZero",
          "informationUri": "https://qwiet.ai"
        }
      },
      "conversion": {
        "tool": {
          "driver": {
            "name": "ng-sast"
          }
        },
        "invocation": {
          "arguments": [],
          "executionSuccessful": true,
          "commandLine": "",
          "endTimeUtc": "2025-03-25T01:48:17Z",
          "workingDirectory": {
            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils"
          }
        }
      },
      "invocations": [
        {
          "executionSuccessful": true,
          "endTimeUtc": "2025-03-25T01:48:17Z",
          "workingDirectory": {
            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils"
          }
        }
      ],
      "results": [
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3fb7ccb57bef3a6495348c10fc9ba8561dbff99df3d39a691d16c3f1e7ad16fe"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b75eef10d73ccf97372aa9418646fa8662994679a21e40ecd2cecf4bd6a1bf19"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4d5dc4e472abfd0d9ad6500d9317cc39899b7e4190aa766f465bff6bb047f741"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "25cf424195bdaa426d4ac78b28d2e562168b311758d1340f5144d671e2d60fba"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "290416da93dcf89f999afe9d117854b70aa0874315861528d27737aae0a55b91"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b64e81edd3123faa580bcbd752dd70ce44fc033088dd034a02cf1b86f99a28d3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "621de08ce3a55abc3b67f20ff9ef31b3a7ecc6d6aa08b2bd15df96b163621816"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "61c9dc3ba2c78d5ddb665b684782b6fc6737386043104d47eacda8a1d498583c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.yaml/snakeyaml@1.23",
            "text": "pkg:maven/org.yaml/snakeyaml@1.23"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f9b992d8cbff4fe9164b2c32b9698221dd101a8ac4efaab640f59a4ea13e4bf3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework.boot/spring-boot-autoconfigure@2.1.2.RELEASE",
            "text": "pkg:maven/org.springframework.boot/spring-boot-autoconfigure@2.1.2.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "9437c72e2d50a7d657473b1df6769df73ab18be4d9286bf7ab49440b3e722fc5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework.boot/spring-boot@2.1.2.RELEASE",
            "text": "pkg:maven/org.springframework.boot/spring-boot@2.1.2.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "45c7bd3922dcb4fe00a5b03cd5697a0cb95a14b1875da643038586cd831e7553"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework.boot/spring-boot@2.1.2.RELEASE",
            "text": "pkg:maven/org.springframework.boot/spring-boot@2.1.2.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "0814cf381964b13902a49a332bc81ffde9693b5317b09da0fbf9bd5df70de847"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework.boot/spring-boot-starter-web@2.1.2.RELEASE",
            "text": "pkg:maven/org.springframework.boot/spring-boot-starter-web@2.1.2.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "271e731694751de348ab9a3230965deee4416084062f5fe3c280773812620336"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework.boot/spring-boot-starter-web@2.1.2.RELEASE",
            "text": "pkg:maven/org.springframework.boot/spring-boot-starter-web@2.1.2.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "fcd46f4b056df98b28ba84ef61acac3cdb2f2a3733bdd09cc966ea1bd3248c2f"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ab1b8cee40a0e915be0cdd6b5eb9d88bb8f2343fca8bd892cbb899d40ed634d1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5f7b074a303e12ff64c2b1650aeeccc6ba34cfa2eecaaa114104a7fa5d89f525"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-context@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6542b4f8f062a1d86dc72193cfa2791ef53e54948c3a22e52eb4e28dfda588b5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "69c5925b165e726e53b8ab2a766c96e73a8ad84976871d54a738ac77cc77f8f6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "1d3e21b83f8a369000c1f4e81e404f05573f9046f23cf0cb191f1e9dc7e539b5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7d22dbf07a4333c345a800e662bdeae88abee6344f08458cf0d5f73206827e61"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5f80364df4836d13424d3231ee33da6757b923e0ba5a01769010dec5f35fcbac"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "eb2ed2df412f7c5f6f58fd5407b8ba6c775d3872fa59022896184f2ec9df7a1a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "77cd5f76fe3e003fd6591daa5da439df1ce578dfecf2e2652fdc5934b02f286c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "25017f161cd9c9dd87c6fb44c72cda2709d03a03f3ac7f90c70f4f8354eb62e7"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b3ca8aa42db025596cdb4e55c0e9d18bb6da2f6220730c203ffa50409e21046b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6210d8f75d5fd2f30a8d0ff43beacbfa011f66c560b8a13c73990f880c083c69"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-core@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "0079bdd14b0199e0d7d1ee07785874cfb0e03d130b72f99bccb2b14b069da8e6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c9af33bb431eac42bc0768f3548edec9a728e17a107bd39ff37d4dc75ab31254"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "a152629079439b1468734b5ea5497c57c7d0a813a82a4d622c992da16a266765"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b41cc4ae80217e7e1f64db997bed898f3da372ceee97345d8b6858542859858a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6abd7b285c220694ee008ae307ec980c5f2949c11c576eacd5a904b82d0b3883"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-expression@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e4eedf95dbc83bc98ddc4950762a94b52c46e07fa6c5f54e97d7208254043877"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7989647f7852b04357d9e13d282d4c13a415e4b6e53529cde272f9c8ccf1e8ab"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "2c53e13eb8a453e3f87467f9a77dc1c4fe8518578405c56b22146b3d7cb502d8"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "61523a946c396cab21512702581ddef87de446dbbd4ff62a2df6509fd01542fb"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-webmvc@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5dabf90f902d83c6929f3d9a2fa0075bd7722b58437fb8477bab665fbe17e48a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ee79986da6ab9a8fe9bf40151c0216c42c254e39671abe675636921955da946d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3f7859ca4e1b44360c0f3a2ca7cde624f3902eef4e998f735da865ded01d88b9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "95c13314bfa1c48ebe0eb4693bc77af0b5e3e5719b42b6450cf1dab6c898d6c3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-beans@5.1.4.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6574960d8c6e0d10a3f74d3a4797957533f2e4eeaeb4c405750dc1487c9a2aaa"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "114d8d4a43cc3a17a69e231050c2e0bf9b32b399d89a337527b8596b2971faa5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "9d2467a99267b38ee310e8c17a0e0c60a55d3e477148aa8ad4db4e85acf01be3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "072a48ea21922dcde91b073f2c113b08b4ec58c9ac9a1f4f4a006c6427fdedc9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "db895b8a14b5e4fa3482aec9c84e5b325ea648bdcb816212ed3a908a4c4b1ad6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "66f63fc3503676e33317f245479d7b33a381124ed9849da2bc7a268b6b000d6f"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "33929b3957655876d00b5901244fa9572eb9dff7040c0bf577b138c3814f04f6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE",
            "text": "pkg:maven/org.springframework/spring-web@5.1.4.RELEASE"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "acdda245e63d621c83a3f9b1130b45b5682b4c79265cc93f6295c5dc2742f9c0"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b9f22b2ec73cc896b44f5f351c841fa1685d2b3265343825896b307082f607c9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3933246e9f9170f65a039ca16910ae69680df33ffae9ee9dbfde3c120528728c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "743f7cc441cc027aa8a3956444edca63d29086271daa3f82619ce36fe4e09e6c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f03b920a0831acabd3c442a4f2510736eb1a80f258dce305034a97c1dbe13694"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "1f9d8b6ee955f0b6ead4cdb74b69cf37133d1b579db6cff34a3482986617771b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "04765c66e21d4548f9fde736c582c13ce688e0e291d89028f82e70ade2845e05"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7612287877b63e2d6a5665a6b05f0f721099eb75a677bd3a699f319751ef02f5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "d7d8a6e6d8e3ffde68acfee1663e2e15d3207f9ae2632f30b05a57497f1f11f0"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.jsoup/jsoup@1.8.3",
            "text": "pkg:maven/org.jsoup/jsoup@1.8.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "51e8e50ccd2227e28915ca9991b2bd6d4d730deb0bbe8435023e17a1e721404d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.jsoup/jsoup@1.8.3",
            "text": "pkg:maven/org.jsoup/jsoup@1.8.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b0b5f53ab4aab58bd07552236db6a43af1a588e748528b791c58e430f2a802ce"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.hibernate.validator/hibernate-validator@6.0.14.Final",
            "text": "pkg:maven/org.hibernate.validator/hibernate-validator@6.0.14.Final"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "9dd6349c6c715c1df9037605aa5942ffd72085af8ed9e018c27202fd13d01aa5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.hibernate.validator/hibernate-validator@6.0.14.Final",
            "text": "pkg:maven/org.hibernate.validator/hibernate-validator@6.0.14.Final"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e40b308c2dd1ec6aa2f78158db3584a875714f3add9a6a88bc1d949bf6f892b4"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "57487113e33970e911604707df88b2c31939b34567013ba0a5465e4963996c55"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "285102edc7fcb98015b46ce83be1ea465333b986c4058ff08c2f8a52d4626bf7"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4d3f11f413a150c360e10fd119cf3c85162a4c89f6f3db22a03e12e5752686c0"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "78581c883568601244ee3b44ffaabde1b9b424b2c8fe8cf55c9fe26b666a893d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "cd62469807119d0b1d3318d712335bcc23ba3dc8d3d31ed87e2f2bf20ecf4ae4"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-websocket@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7e2fd11f4f3cdbec03606a9a84033a925b2f7303fcaaae10a2dc65922a79627c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ddf7de489fc934aae578a6b176bbb7958b0a321446660e010d302a09d58bdf45"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "d54a36eb654435fbdadf48688161e90ce891e4748673224ebf99348c9833e5c5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "98d001fe01245c560a9630ce22764f9c08952f8b014647af01b6b508df95e3d3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "39493252f85cd20a094c9cce8c74378ef863817d15455175005b018c809dd513"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "09083150ae88b95c294b7b1a619c70d395bfa3cce371e1fd711d716ad36a2634"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c996d6398e468af58a52287c84bfa9d1921866af94f48f0ae4ecb2b5d8823ba9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "78f85360dafa0ee22fa5d07df3d5fe6504d1ba679713dec97b1ab92a19c9fd8a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "37b2753aa83c2b46c5873dec87d5b5a0945bf93916c7104e088d89a89007a8cd"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "d2ec40669549318b02652479bd6f7ec288e08f640efdd0ea955cc31492d138a1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "0bb07a144daa686d78b87e39ae89737735f2f66e86a8a474116e9363179427d8"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "653d69cee8389cfc5bee89db1de41a051af65b713cb8fe2965045a18230b76e2"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e1d132fc29132bd80d52e449d82fbb371381503b900cff30be4d952e3e65857e"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "88eff62a693285b9fb7a8abd831efc2d82e7d7d94e60a9cf11ad6f5789b86877"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "fcf3148633bafee8367fa5902b79c98aef6786bbff40eb9fe8412ac63413de7d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "293b0696e65f3a28df0a886592b12f3b0ba2b576184cb55735ca96fc8a62091a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "84cf081f1e13d8e0a2edbdaeaf6e8e170ad8f5000b692052e8bfd67a2e8e7847"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "8f1a58f3002eb066dfa2c5ec29c2bb37e5741f46bbaf504a2dcc464ec7125766"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "44bb2d40d8a091bc4c60bdbaa8e0a2c1c1191ffb19ba33b64c74d217b9bc8aad"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5480c57290ac1047dd11104309ddd45b1f0cbb01bb622e7d7169faae63762dd4"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c0985a44c6bfd88b9cf0b22fd5e0379ae7759cfbbc1f72114ef2185cbbb84e28"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "32879392a9d50cc6480c4ce906f68712563e4e7869749f79d4650721b35b1d74"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3ac6e756c18eedf373773e5bdab31455294a3c92023ac3d749f1d4915df695e1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "406507a4987fbe34d7957a8637a90769c0d662998ff86fd2030cfebab805b4d6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4f434b4f5029c73b8f989e2bba0b1a3c77f951820f1f2616b44500e52f263f5a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "2b37a1e7b755f25a8bac4dbc693403280852365e53cf19b03e18b189e63056a5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "31f2ef96dcd7a62818477deb3a186d868a7ab693c6765596834a571fc706e9bf"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "80a1646270be00db993a31e07952b0bfbb477f2ff95cc97d30317748a876cb36"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "9337c6bd1f64a717c4a2dba1bab4ccda2824c5bb9c31a385a9a7c9aa050fa42c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "254b2b32c71603dcaeb223bee10e4358721ad94b25aa0684171a63829072b6e3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "2b6ee3c670dc8fee46f4ece83b62e3e194c4e07cfca138748b7a3a897ff38bd1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3e70c0d437c93eedcc673d8be0441c0969edb741f32fc07871c1bba2156d946b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "23cd541aac71331ae0399c8aecf4da2bbdddb33b1d74fd9b008917e84830318a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "eb10a693c0a0ba0d69e769d037f90b8632f9bea655438df654b6d3c68d22da99"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6a057f6e0c0b2f88075ecf1e2fd622df7c9668376d1f55fbba8f309a861e9e92"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e9709819a6a4c6b0e39510f9e2af6d9aad6a9b2908ce37788c95beb5d41f8d42"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "648dd5aa1710b8d8f7dc9cdb6ba4789d735b08b08105c09f6fbdbe1fffca2f4f"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ddf6731ce905824016081350c00fe8d68163437f0796103580746b34f28b494a"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14",
            "text": "pkg:maven/org.apache.tomcat.embed/tomcat-embed-core@9.0.14"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "362551e34bd826d1177f472637fa5f97b89a88c98cb5ea1c3ab34204efb2ffc4"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1",
            "text": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "8dc6ecc98763fe54d4c5b139bcf13400b914e6c3de815f64f2413dc2592a9159"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1",
            "text": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e929c7887b4d57652a70e894a6bc21dfafcf3018e6fd98631bd4cce2602f5769"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1",
            "text": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "adf96f86213a98ab52249ff3b7a1e51434f1a59e96d64a0b5faf35dafa62595c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1",
            "text": "pkg:maven/org.apache.logging.log4j/log4j-api@2.11.1"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "16d4f02287fb5ed704a5f403aaedec130391b4b3e32dfe9ea87692723db44343"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "417ad4c6309eba1c06811b5e76093224de3499869ffdb5a71e8d192676d3df63"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5eca85bacb6a679fe8efcb5a0d919cb3f522aed2038c2f9dd1bbecfeac891cfd"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "575b6c58301ed885128629fcf83aa0d98a7ef68b05db69b8083f7b4f7048bc75"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6ea26c3cdc76c111f59275e29bd146894fc09f3af4d7ae0974153b2ae72b523b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4c5ff8f47a19b139da55b402ceab3faaf1f57cce0a6035ab7c79dc1796859efe"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "8b808a7c159639987b6fdae4b39b4c9bf3a52bcc3454a6a2e6059bb9844a1668"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c9f17c9d8f6b20b0a2a961ad491efa654b8213a74515b8231bcfbdc33ac070b2"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3734094b6b18ec3253e2486c8043f10fd4bdafc4ef6087e3210caed0c5750625"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "27be17b2092695d2dca313991590ba63760ee75cb9419760eb70ae536245af14"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "582871b889750d18d4803c2a715da2ce9cd047e19ec0225d80fb268381b8c0e9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4b3bfda66d87dfa09bd31a6ed30d98bc2a9f89cfa0dcb3b9e7027a6f890b8f54"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c56694b9937fd67e0a96a477b485b24ede76702d013347fdfa66694197a75468"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e0a38728d5c9c1caedf769c63537453047910ae302067c1223b639010352c337"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "bf6b2bb9dc819b73d0f72af0fd519390b13641554cde213e66e3be398ab8bcc9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f0e4c54cf396e2af05a26ff7be355f4017f30dedef2cf55326231942cced4774"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3a541bac4025bb14a2bf0ad084deba71c056c9a57460abb6e1f564dc3fbd863d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "31a668f9999ad623938d07b41787a4d7fc44d08d6a2cdbe5754c46ae30593395"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "717a746cb9de92df5109bf69f5c1d8adebd8024325997d37952f2642fe25d1f1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ba202fc01589e2b68cc3d8a57a74450b2e252fa20972d66080b00e40cc54656c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5f376e1b2cfb0e22b983e5dd45be2468a219289c8c856b687dcebf61738c58ed"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "586a4c6529c8dc11f6029a30157016eaae536cdd72888e0f7bf96fd316037f98"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b1fb0d00aa8c936ac846a7cfd82d1096b50697a1e2dbe297b83faddc773a1af9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4f2617da8c06a059aa6ac806bdda09b16eb03ad94c0de73179ad1e03245e482f"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "9f8d96ed0d36999d5240514ab9b4c7546f49119a1d96ff54d379b0fe18f9a39e"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "4122ad11a6eeb19cdbbed41b90985249fc77f3bb9cafcddbe1aaabbc554d6ed1"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "e3762ea27d85cca32b937ef3076b166cc3efbbb70308b234b7b2d80f1579c085"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f45f2927c863d71dd6edccfe162071991bd92893eaa1ef459b17bff942fdb4e3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3ebcfc00f36dc5608312d0fa81ab23bc566d1d4fc01232fcfa41a87f16ebf355"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "bff8dd5d9ce86c2b08e1793006d59ec6cbe09432787b542b7b2a614b2d2416be"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "8fba830db15e461e4ab343ff7671f529096dd8cdbcf94c0f56a9c9476a8623a6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "06b1d97507afa1976a3e68eb03022e9b7e31bb37211c378cb5ec441f161f6dc8"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "5ee08bbc95230cb9219a187d84b75a9f9fdde7c9f6139ba7f7b9c517ad4bd683"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "437ae7039369fa919e205547c6c15fe08feb8edcd348c35a66c6b3f833e4fbd9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "65edd8a2c6d106627cc43446ca54db6614810862424b3c721401e4522a1f9073"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "0c1e109d6b0f70d032fd5afaee79a32c73d21d07b7865bbef31f13df9c9b6958"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "2cb2f0fa7dda349ea0fe2292ee4417dafe46c580068a65dee934304abafa75cb"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "50140756b4ceb14814ea1370eed4fbae64ed7c81f3dbf8455de9cdceb8b8c221"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "78ab87d5bfa64adf6c26432e552c0fa513f25aae54c30fa8b33574d015d7e3c4"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "cc728aa536db9399938104f903d59e73466f4b8fb16a9e2ef4058ddb752eb88f"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "43571b471dc7e8d5441931d13a347878b6dc1b797d91ec8a5813a1c85057899e"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "45d9bef0ce7881fa6984157b61c4e8f58ba1af1ffdd7fbd2db3785642cf2deae"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "2f28020d13db3c168ba5cc5ddf88699befa6fbd00c590ce04c2cf61aded7b94c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6b76770495f6a2daa7a1ad20d2098a11cd5d56f6cded72afb312c88a390b20dc"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3803fa6b4d1289ca43de28af934f5465fbc4800925a454fdb4784a19e53134ed"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "537072a4963b074967d5ddc20b5e9922eabefcc3ba70fd4f223efa8eeda7778e"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7c63d5a25dc7fc204c28f13c299b428f089a622beb74c2ccf4886a1e857dcd71"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "23c0ae631c616d609396ded3d6c4a47a8c4343a4a1f7ad1ea0138348e006999b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "ffd9544a930aeadb6e17605215fe24bd148121ae453a903e713cf2c76132bece"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "142b81be0fd9244761cd190cfb464eace187fab591f79201f24e1dce14ca74da"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "287075414a05f11e670eae962cd3f81cbccbd088937c18ce74bbb47a28a7a5b6"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "1ba79a069e4db32e19e9b723134420a8ea88ae3ea3161f1f65c8365ead3c3000"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6dca0152e4b56adad7e5237e99601e2d0853ed839e0471b3b9ec14fcef8d3f2d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8",
            "text": "pkg:maven/com.fasterxml.jackson.core/jackson-databind@2.9.8"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "6de423da1974cd53d56915140a50bdb88b54e11e6f14d379d9c25b33bb75a6d5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/ch.qos.logback/logback-core@1.2.3",
            "text": "pkg:maven/ch.qos.logback/logback-core@1.2.3"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "301d1bddc8e127a5e067b59c772cc3d73ff672dbfe5278f4b4ea3f9c3384b737"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/ch.qos.logback/logback-core@1.2.3",
            "text": "pkg:maven/ch.qos.logback/logback-core@1.2.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "bb974edc99c1e95b12bc8657fb98a64387e470a505899dc43aa255d7cdfe21c3"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/ch.qos.logback/logback-core@1.2.3",
            "text": "pkg:maven/ch.qos.logback/logback-core@1.2.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "c84c3be6a2af97bbd1a6bd6e656af909e77a4ce54682c0db04192311e17235e0"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/ch.qos.logback/logback-core@1.2.3",
            "text": "pkg:maven/ch.qos.logback/logback-core@1.2.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "8899a99f468532dca124eb5fd15f7b1712c0c7372d0a1fcb3e0e41c7bdd280dc"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/ch.qos.logback/logback-classic@1.2.3",
            "text": "pkg:maven/ch.qos.logback/logback-classic@1.2.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/NA"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f1c5f7d5f1d911a8a55949ce0120a8c7e7b20453697481358d77b0114c508115"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `LoginController.login`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in LoginController.login"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 17
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 17
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "3b02ddb66b20780ba231d90606f5aee535cdcd42ce6014a9957d0c580517e790"
          },
          "ruleId": "overly-permissive-cors",
          "ruleIndex": 1
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b9f22b2ec73cc896b44f5f351c841fa1685d2b3265343825896b307082f607c9"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `CommentsController.deleteComment`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in CommentsController.deleteComment"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 29
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 29
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "4d2f888ed2dd2b89f9f265c654bb755c23064a46022fc65ed9d2b0a464971ea2"
          },
          "ruleId": "overly-permissive-cors",
          "ruleIndex": 1
        },
        {
          "message": {
            "markdown": "Ensure an IAM role is attached to EC2 instance",
            "text": "Ensure an IAM role is attached to EC2 instance"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 91
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "5c8fdc7f7ce7aea046d1831d2a9720bba4dff6660ece89bf38c8fc1292ffcc9f"
          },
          "ruleId": "CKV2_AWS_41",
          "ruleIndex": 2
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "3933246e9f9170f65a039ca16910ae69680df33ffae9ee9dbfde3c120528728c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `CommentsController.createComment`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in CommentsController.createComment"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 23
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 23
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "3eaf76f0b0730a74aa93eed9f9daefccf1d430fda081023ec6152defb132adf3"
          },
          "ruleId": "overly-permissive-cors",
          "ruleIndex": 1
        },
        {
          "message": {
            "markdown": "Ensure the default security group of every VPC restricts all traffic",
            "text": "Ensure the default security group of every VPC restricts all traffic"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 5
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 5
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "b542d8bdb9a63b3f39fd561f8fe135b454aa2b792d463bf4f19d4088dd31048c"
          },
          "ruleId": "CKV2_AWS_12",
          "ruleIndex": 3
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "743f7cc441cc027aa8a3956444edca63d29086271daa3f82619ce36fe4e09e6c"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Cross-Site Request Forgery: Overly Permissive CORS Policy in `CommentsController.comments`",
            "text": "Cross-Site Request Forgery: Overly Permissive CORS Policy in CommentsController.comments"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 16
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 16
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "e0ec05b1542f5c257b2e76b4da6c0c617326c046dc07ce63e02ef34e5c7c199e"
          },
          "ruleId": "overly-permissive-cors",
          "ruleIndex": 1
        },
        {
          "message": {
            "markdown": "Ensure VPC flow logging is enabled in all VPCs",
            "text": "Ensure VPC flow logging is enabled in all VPCs"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 5
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 5
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "46ed5539ac9503c72ebc566e5383e38df0d33b9b796bbbe7a739a18840a5a4ea"
          },
          "ruleId": "CKV2_AWS_11",
          "ruleIndex": 4
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "f03b920a0831acabd3c442a4f2510736eb1a80f258dce305034a97c1dbe13694"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in `LoginController.login`",
            "text": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in LoginController.login"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 27
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 43
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/User.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "c9d4e858f15fbe2a9eaa2a227c5c1effb9137637942829a5297776b468d47be4"
          },
          "ruleId": "exit-from-attacker-controlled",
          "ruleIndex": 5
        },
        {
          "message": {
            "markdown": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted",
            "text": "Ensure all data stored in the Launch configuration or instance Elastic Blocks Store is securely encrypted"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 91
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "d573654740222021a7ea37adbef772110e07fea472cc8c14c96956a7d73224da"
          },
          "ruleId": "CKV_AWS_8",
          "ruleIndex": 6
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "1f9d8b6ee955f0b6ead4cdb74b69cf37133d1b579db6cff34a3482986617771b"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in `CommentsController.createComment`",
            "text": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in CommentsController.createComment"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 27
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 25
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Comment.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 78
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Comment.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "d0a011734ac213803e69764b624011c229b9969e03cc28d8996994d3e9dbecd0"
          },
          "ruleId": "exit-from-attacker-controlled",
          "ruleIndex": 5
        },
        {
          "message": {
            "markdown": "Ensure that detailed monitoring is enabled for EC2 instances",
            "text": "Ensure that detailed monitoring is enabled for EC2 instances"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 91
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "2ac5b9d78710087c7a17ee4ed5d4567802472c35d11a50443b21c7b76dd5414d"
          },
          "ruleId": "CKV_AWS_126",
          "ruleIndex": 7
        },
        {
          "message": {
            "markdown": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in `CommentsController.deleteComment`",
            "text": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in CommentsController.deleteComment"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 27
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 31
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 32
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 65
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Comment.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "e0f5a0537f6a2a5d6b29763cb2bc5300cb98b7253412140f1a9fd2964e5fe427"
          },
          "ruleId": "exit-from-attacker-controlled",
          "ruleIndex": 5
        },
        {
          "message": {
            "markdown": "Ensure Instance Metadata Service Version 1 is not enabled",
            "text": "Ensure Instance Metadata Service Version 1 is not enabled"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 91
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "30c5a3db609e396d34a04f35d6b216c10ab6eac1cd726c65e13ddb9bf2b050fa"
          },
          "ruleId": "CKV_AWS_79",
          "ruleIndex": 8
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "04765c66e21d4548f9fde736c582c13ce688e0e291d89028f82e70ade2845e05"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in `CommentsController.comments`",
            "text": "Denial of Service: Program is Terminated From Handler of Attacker-Controlled Inputs in CommentsController.comments"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 27
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 18
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CommentsController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 40
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Comment.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 27
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "5210be2920b0cbeacee5410aae4ba688f63e68a3f7d356335baebfb6c71241e2"
          },
          "ruleId": "exit-from-attacker-controlled",
          "ruleIndex": 5
        },
        {
          "message": {
            "markdown": "Ensure that EC2 is EBS optimized",
            "text": "Ensure that EC2 is EBS optimized"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 91
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 91
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "25ed0be786594aa4004a8866830227aa217a713a2aeba9c44eef0843abcae830"
          },
          "ruleId": "CKV_AWS_135",
          "ruleIndex": 9
        },
        {
          "message": {
            "markdown": "Weak Hash: Usage of Weak Cryptographic Hash Function in `Postgres.md5`",
            "text": "Weak Hash: Usage of Weak Cryptographic Hash Function in Postgres.md5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 67
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 67
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "d7e805b0929f78b19d974133438bbd6b97fe41d2e5b740fcaa4c6886dc0cce28"
          },
          "ruleId": "weak-hash",
          "ruleIndex": 10
        },
        {
          "message": {
            "markdown": "Ensure every security group and rule has a description",
            "text": "Ensure every security group and rule has a description"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 48
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 48
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "411c6b79cc99917d808e6c4757b1e251d25efdb65cbab1ab418f5c405389dd00"
          },
          "ruleId": "CKV_AWS_23",
          "ruleIndex": 11
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "7612287877b63e2d6a5665a6b05f0f721099eb75a677bd3a699f319751ef02f5"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Security Best Practices: Hash Generated Without Salt in `Postgres.md5`",
            "text": "Security Best Practices: Hash Generated Without Salt in Postgres.md5"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 71
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 67
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 71
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Postgres.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "57c4a1ee26a65becf019836f6811b4481383d0c1a72dd259d39888a9e03248a9"
          },
          "ruleId": "unsalted-one-way-hash",
          "ruleIndex": 12
        },
        {
          "message": {
            "markdown": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1",
            "text": "Ensure no security groups allow egress from 0.0.0.0:0 to port -1"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 48
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 48
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "c0582dc5d4c3f7b37b88a598d306aaad1aa969e48870e6f73d348294eb3886d9"
          },
          "ruleId": "CKV_AWS_382",
          "ruleIndex": 13
        },
        {
          "message": {
            "markdown": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via `url` in `LinksController.links`",
            "text": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via url in LinksController.links"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 16
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 16
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 17
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 14
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 16
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "9885126562da9b0f595da21a64a72929728612d033e05528128d66434d9f08cf"
          },
          "ruleId": "ssrf-attacker",
          "ruleIndex": 14
        },
        {
          "message": {
            "markdown": "Ensure no security groups allow ingress from 0.0.0.0:0 to port 22",
            "text": "Ensure no security groups allow ingress from 0.0.0.0:0 to port 22"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 48
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 48
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "12724a8cbdd4e9b158c8e43f37cb5c01d7e879c1c4566164098cd5543c0c7a91"
          },
          "ruleId": "CKV_AWS_24",
          "ruleIndex": 15
        },
        {
          "message": {
            "markdown": "pkg:maven/org.postgresql/postgresql@42.2.5",
            "text": "pkg:maven/org.postgresql/postgresql@42.2.5"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "d7d8a6e6d8e3ffde68acfee1663e2e15d3207f9ae2632f30b05a57497f1f11f0"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via `url` in `LinksController.linksV2`",
            "text": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via url in LinksController.linksV2"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 16
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 21
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 24
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 32
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 14
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 16
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "bdf7bb2ca8da9a15709b6f245a4de73f63afe4e17df27960e4090197127edc73"
          },
          "ruleId": "ssrf-attacker",
          "ruleIndex": 14
        },
        {
          "message": {
            "markdown": "Ensure VPC subnets do not assign public IP by default",
            "text": "Ensure VPC subnets do not assign public IP by default"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 33
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "",
            "issue_tags": {}
          },
          "baselineState": "new",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 33
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/reverse_shell/main.tf"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "007d14acd89b481c74834259d84c51a1b2a641240f44786206305b422df5e34f"
          },
          "ruleId": "CKV_AWS_130",
          "ruleIndex": 16
        },
        {
          "message": {
            "markdown": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via `url` in `LinksController.linksV2`",
            "text": "Server-Side Request Forgery: Attacker-Controlled Data Used in URL via url in LinksController.linksV2"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 26
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 21
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinksController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 24
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 26
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LinkLister.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "b31167997b9706cc20d311b0c1c5f6139f1fd57cc45df7dfe211d6f9a447e15b"
          },
          "ruleId": "ssrf-attacker",
          "ruleIndex": 14
        },
        {
          "message": {
            "markdown": "SQL Injection: Attacker-controlled Data Used in SQL Query via `input` in `LoginController.login`",
            "text": "SQL Injection: Attacker-controlled Data Used in SQL Query via input in LoginController.login"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 49
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/User.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 19
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 20
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/LoginController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 39
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/User.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 47
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/User.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 49
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/User.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "cec9ef2a46dee135877411a15d144e371a089f381cbc02be9539095ceff08ce7"
          },
          "ruleId": "sql-injection-attacker-controlled",
          "ruleIndex": 17
        },
        {
          "message": {
            "markdown": "pkg:maven/org.jsoup/jsoup@1.8.3",
            "text": "pkg:maven/org.jsoup/jsoup@1.8.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "51e8e50ccd2227e28915ca9991b2bd6d4d730deb0bbe8435023e17a1e721404d"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "pkg:maven/org.jsoup/jsoup@1.8.3",
            "text": "pkg:maven/org.jsoup/jsoup@1.8.3"
          },
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 1
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/https%3A/github.com/elangosenthilnathan/vulnado/blob/bf1a7e49af150ef680ed7d47b3a63e34f0df09db/pom.xml"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "MODERATE",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "partialFingerprints": {
            "evidenceFingerprint": "b0b5f53ab4aab58bd07552236db6a43af1a588e748528b791c58e430f2a802ce"
          },
          "ruleId": "oss_vuln",
          "ruleIndex": 0
        },
        {
          "message": {
            "markdown": "Security Best Practices: `alert()` Function Used in Production in `login.js:<lambda>0.<lambda>1.<lambda>2`",
            "text": "Security Best Practices: alert() Function Used in Production in login.js:<lambda>0.<lambda>1.<lambda>2"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 15
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/client/js/login.js"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 15
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/client/js/login.js"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "d669ab33f6dc307299aaa9bd0cb8ddae0077ab63cc73a6a871258903d341f936"
          },
          "ruleId": "alert-in-production",
          "ruleIndex": 18
        },
        {
          "message": {
            "markdown": "Security Best Practices: `alert()` Function Used in Production in `index.js:<lambda>0.<lambda>8`",
            "text": "Security Best Practices: alert() Function Used in Production in index.js:<lambda>0.<lambda>8"
          },
          "level": "note",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 55
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/client/js/index.js"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "LOW",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 55
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/client/js/index.js"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "f83be5da8cbf0e6f3b89331c3566dd9b33863c8f43fe9702c591366f40c2c6ba"
          },
          "ruleId": "alert-in-production",
          "ruleIndex": 18
        },
        {
          "message": {
            "markdown": "Remote Code Execution: Command Injection Through Attacker-controlled Data via `input` in `CowController.cowsay`",
            "text": "Remote Code Execution: Command Injection Through Attacker-controlled Data via input in CowController.cowsay"
          },
          "level": "error",
          "locations": [
            {
              "physicalLocation": {
                "region": {
                  "snippet": {
                    "text": ""
                  },
                  "startLine": 11
                },
                "artifactLocation": {
                  "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Cowsay.java"
                }
              }
            }
          ],
          "properties": {
            "issue_confidence": "HIGH",
            "issue_severity": "CRITICAL",
            "issue_tags": {}
          },
          "baselineState": "unchanged",
          "codeFlows": [
            {
              "threadFlows": [
                {
                  "locations": [
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 12
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CowController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 13
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/CowController.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 7
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Cowsay.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 9
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Cowsay.java"
                          }
                        }
                      }
                    },
                    {
                      "location": {
                        "physicalLocation": {
                          "region": {
                            "snippet": {
                              "text": ""
                            },
                            "startLine": 11
                          },
                          "artifactLocation": {
                            "uri": "file:///Users/elangosenthilnathan/Documents/Code/field-integrations/shiftleft-utils/src/main/java/com/scalesec/vulnado/Cowsay.java"
                          }
                        }
                      }
                    }
                  ]
                }
              ]
            }
          ],
          "partialFingerprints": {
            "evidenceFingerprint": "a5c6654a7b5628e2fb4c8de291e44dbd864fdc3146d28dc32442f0b4b416b109"
          },
          "ruleId": "command-injection-attacker-controlled",
          "ruleIndex": 19
        }
      ],
      "automationDetails": {
        "description": {
          "text": "Static Analysis Security Test results using ng-sast"
        },
        "guid": "882e3df0-bc1a-4939-bbec-9e7aa6626671"
      },
      "versionControlProvenance": [
        {
          "branch": "",
          "repositoryUri": "",
          "revisionId": ""
        }
      ]
    }
  ],
  "version": "2.1.0",
  "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
  "inlineExternalProperties": [
    {
      "guid": "882e3df0-bc1a-4939-bbec-9e7aa6626671",
      "runGuid": "2a778419-f0fe-4670-978c-05ebf8e1b58c"
    }
  ]
}